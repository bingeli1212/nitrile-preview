'use babel';
const { NitrilePreviewHtml } = require('./nitrile-preview-html');
const { NitrilePreviewPresentation } = require('./nitrile-preview-presentation');
const all_op_icons = {'pencil':'&#x270E;','poly':'&#x269E;','rect':'&#x25AD;','elli':'&#x2B2D;','select':'&#x2B1A;','smudge':'&#x26C6;','eraser':'&#x232B;','cplane':'&#x1D465;&#x1D456;','ball':'B','xyplane':'&#x1D465;&#x1D466;','hand':'&#x270B;'};
const all_st_icons = ['&#x2758;','&#x2759;','&#x275A;'];
const all_sh_icons = ['&#x2216;','&#x25AD;','&#x25FA;','&#x2B2D;'];
const all_wg_icons = ['&#x269D;','&#x269E;','&#x26C6;','&#x26CA;'];
const all_at_icons = {'clear':'&#x2613;','cropp':'&#x26BF;','fopen':'&#x1F4C2;','dload':'&#x2728;','zoomo':'&#x2315;&#x207B;','zoomi':'&#x2315;&#x207A;','rotcl':'&#x2B6F;','rotcr':'&#x2B6E;','flipv':'&#x2B65;','fliph':'&#x2B64;','acton':'&#x2318;','cutbd':'&#x2702;','paste':'&#x26E8;','rsize':'&#x26DE;','uload':'&#x26A1;','darkb':'&#x263E;','fg2bg':'&#x2B14;','bg2fg':'&#x2B15;'};
class NitrilePreviewFlowerpot extends NitrilePreviewHtml {
  constructor(parser) {
    super(parser);
    this.name = 'flowerpot';
    this.presentation = new NitrilePreviewPresentation(this);
    this.icon_subpoint = '&#x261E;'//WHITE RIGHT POINTING INDEX
    this.icon_solution = '&#x270D;'//WRITING HAND
    //this.icon_folder = '&#x2668;'//HOT SPRING  
    this.icon_folder = '&#x2615;'//HOT BEVERAGE
    this.uchar_checkboxo = '&#x2610;' //BALLOT BOX            
    this.uchar_checkboxc = '&#x2611;' //BALLOT BOX WITH CHECK
    this.uchar_checkboxx = '&#x2612;' //BALLOT BOX WITH X
    this.n_para = '6pt';
    this.n_pack = '0.0pt';
    this.n_half = '2.25pt';
    this.n_marginleft = '105px';
    this.n_marginright = '30px';
    this.slide_width = 140;//mm
    this.slide_height = 106;//mm
    this.vw = Math.round(140*this.MM_TO_PX);//529
    this.vh = Math.round(106*this.MM_TO_PX);//400
    this.board_width = parseInt(114*this.MM_TO_PX);
    this.board_height = parseInt(80*this.MM_TO_PX);
    // console.log(this.vw,this.vh)
    this.bgsvg0 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 529 400"> 
        <rect x="0" y="0" width="529" height="400" stroke="none" fill="#DDEEFF"/> 
    </svg>`;
    this.bgsvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 529 400"> 
        <rect x="0" y="0" width="529" height="400" stroke="none" fill="#F4F4F4"/> 
        <rect x="0" y="0" width="529" height="40" stroke="none" fill="#DDEEFF"/> 
        <rect x="0" y="0" width="88" height="400" stroke="none" fill="#DDEEFF"/> 
        <rect x="0" y="360" width="529" height="40" stroke="none" fill="#B3DAFF"/> 
    </svg>`;
    this.add_css_map_entry(this.css_map,
      'TITLE', [
        'margin-top:6px',
        'margin-bottom:0px',
        'margin-left:16px',
        'margin-right:0px',
        'font-size:1.20em',
        'min-height: 21px',
        'line-height: 1em',
        'position: relative',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'TITLE2', [
        'margin-top:0px',
        'margin-bottom:10px',
        'margin-left:16px',
        'margin-right:0px',
        'font-size:0.60em',
        'font-style:oblique',
        'letter-spacing:0.05em',
        'min-height: 10px',
        'line-height: 1em',
        'position: relative',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'PARAGRAPH', [
        'margin-top: 5pt',
        'margin-bottom: 5pt',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'FIGURE, COLUMN, LISTING, EQUATION, LONGTABU', [
        'margin-left: 0pt',
        'margin-right: 0pt',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'DD', [
        'margin-left: 0em',
        'padding-left: 3em',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'OL', [
        'padding-left: 2em',
      ]
    );
    this.add_css_map_entry(this.css_map,
      'UL', [
        'padding-left: 2em',
      ]
    );
  }
  to_peek_document() {
    var toc = [];
    var pages = [];
    var title_html = this.to_titlepage(pages);
    var main_html = this.to_main_html(toc,pages);
    return `${title_html}\n${main_html}`;
  }
  to_data() {
    var toc = [];
    var pages = [];
    var title_html = this.to_titlepage(pages);
    var main_html = this.to_main_html(toc,pages);
    var totalpagenum = pages.length;
    var allsidesvgs = [];
    toc.forEach((p) => {
      let s = this.to_sidesvg_for_id(p.id,toc,30);
      s = encodeURIComponent(s);
      s = `      --side${p.id}: url("data:image/svg+xml,${s}");`;
      allsidesvgs.push(s);
    })
    if(1){
      let s = this.to_sidesvg_for_id(0,toc,30);
      s = encodeURIComponent(s);
      s = `      --side0: url("data:image/svg+xml,${s}");`;
      allsidesvgs.push(s);
    }
    var allsidemaps = [];
    toc.forEach((p,i) => {
      let s = this.to_sidemap_for_id(p.id,toc,i,30);
      allsidemaps.push(s);
    })
    if(1){
      let s = this.to_sidemap_for_id(0,toc,-1,30);
      allsidemaps.push(s);
    }
    // background-repeat: no-repeat, no-repeat, no-repeat;
    // background-position: top left, top left, top left;
    // background-size: 88px 40px, 80px 400px, cover;
    var logofile = this.conf_to_string('logofile');
    var script = this.to_setup_script();
    var stylesheet = `\
:root {
  --logosvg: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSI4ODAiCiAgIGhlaWdodD0iNDAwIgogICB2aWV3Qm94PSIwIDAgMjMyLjgzMzM1IDEwNS44MzMzMyIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnOCIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4wLjIgKGU4NmM4NzA4LCAyMDIxLTAxLTE1KSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZmxvd2VycG90LnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczIiPgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBpbmtzY2FwZTpjb2xsZWN0PSJhbHdheXMiCiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQxNDA1Ij4KICAgICAgPHN0b3AKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6IzIyNTUwMDtzdG9wLW9wYWNpdHk6MSIKICAgICAgICAgb2Zmc2V0PSIwIgogICAgICAgICBpZD0ic3RvcDE0MDEiIC8+CiAgICAgIDxzdG9wCiAgICAgICAgIHN0eWxlPSJzdG9wLWNvbG9yOiNlZWY0ZDc7c3RvcC1vcGFjaXR5OjEiCiAgICAgICAgIG9mZnNldD0iMSIKICAgICAgICAgaWQ9InN0b3AxNDAzIiAvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDEzOTAiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Ik0gMjMuNzE5NzM2LDguMjE5NzEwNyA3NC45MTY3OSwxLjQwOTA5MjcgNDcuOTA5MTY5LDcuNTE1MTYzNyA4OS40Nzc0MTksMy41MjI3MzI3IDQ5LjA4MzQxNCwxMC4zMzMzNSA4Mi40MzE5NTQsMTIuNDQ2OTkgNDYuMDMwMzc5LDEyLjIxMjE0MSA4My4zNzEzNDksMjMuMDE1MTg4IFoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDEzNzciCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Ik0gMjMuNzE5NzM2LDguMjE5NzEwNyA3NC45MTY3OSwxLjQwOTA5MjcgNDcuOTA5MTY5LDcuNTE1MTYzNyA4OS40Nzc0MTksMy41MjI3MzI3IDQ5LjA4MzQxNCwxMC4zMzMzNSA4Mi40MzE5NTQsMTIuNDQ2OTkgNDYuMDMwMzc5LDEyLjIxMjE0MSA4My4zNzEzNDksMjMuMDE1MTg4IFoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDEzNjQiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Im0gMTI0LjIzNTA2LDI1LjM2MzY3OSA1MS4xOTcwNSwtNi44MTA2MTggLTI3LjAwNzYyLDYuMTA2MDcxIDQxLjU2ODI1LC0zLjk5MjQzMSAtNDAuMzk0MDEsNi44MTA2MTcgMzMuMzQ4NTQsMi4xMTM2NCAtMzYuNDAxNTcsLTAuMjM0ODQ5IDM3LjM0MDk3LDEwLjgwMzA0NyB6IgogICAgICAgY29weXR5cGU9InNpbmdsZV9zdHJldGNoZWQiCiAgICAgICBwcm9wX3NjYWxlPSIxIgogICAgICAgc2NhbGVfeV9yZWw9ImZhbHNlIgogICAgICAgc3BhY2luZz0iMCIKICAgICAgIG5vcm1hbF9vZmZzZXQ9IjAiCiAgICAgICB0YW5nX29mZnNldD0iMCIKICAgICAgIHByb3BfdW5pdHM9ImZhbHNlIgogICAgICAgdmVydGljYWxfcGF0dGVybj0iZmFsc2UiCiAgICAgICBoaWRlX2tub3Q9ImZhbHNlIgogICAgICAgZnVzZV90b2xlcmFuY2U9IjAiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic2tlbGV0YWwiCiAgICAgICBpZD0icGF0aC1lZmZlY3QxMzM4IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJNIDQuMzA3NDM2NSwzLjE1MTc4MjggMTEuNjk2NjE2LDIuMzQ2MzI3MiA4LjkzMDA1MTIsMi45NzY2ODM2IDEyLjcxMjE5MSwyLjk0MTY2MzkgOC45MzAwNTEyLDMuMzYxOTAxNiAxMi4xMTY4NTQsMy43NDcxMTk2IFoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDEzMjUiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Ik0gNC4zMDc0MzY1LDMuMTUxNzgyOCAxMS42OTY2MTYsMi4zNDYzMjcyIDguOTMwMDUxMiwyLjk3NjY4MzYgMTIuNzEyMTkxLDIuOTQxNjYzOSA4LjkzMDA1MTIsMy4zNjE5MDE2IDEyLjExNjg1NCwzLjc0NzExOTYgWiIKICAgICAgIGNvcHl0eXBlPSJzaW5nbGVfc3RyZXRjaGVkIgogICAgICAgcHJvcF9zY2FsZT0iMSIKICAgICAgIHNjYWxlX3lfcmVsPSJmYWxzZSIKICAgICAgIHNwYWNpbmc9IjAiCiAgICAgICBub3JtYWxfb2Zmc2V0PSIwIgogICAgICAgdGFuZ19vZmZzZXQ9IjAiCiAgICAgICBwcm9wX3VuaXRzPSJmYWxzZSIKICAgICAgIHZlcnRpY2FsX3BhdHRlcm49ImZhbHNlIgogICAgICAgaGlkZV9rbm90PSJmYWxzZSIKICAgICAgIGZ1c2VfdG9sZXJhbmNlPSIwIiAvPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNrZWxldGFsIgogICAgICAgaWQ9InBhdGgtZWZmZWN0MTMxMiIKICAgICAgIGlzX3Zpc2libGU9InRydWUiCiAgICAgICBscGV2ZXJzaW9uPSIxIgogICAgICAgcGF0dGVybj0iTSA0LjMwNzQzNjUsMy4xNTE3ODI4IDExLjY5NjYxNiwyLjM0NjMyNzIgOC45MzAwNTEyLDIuOTc2NjgzNiAxMi43MTIxOTEsMi45NDE2NjM5IDguOTMwMDUxMiwzLjM2MTkwMTYgMTIuMTE2ODU0LDMuNzQ3MTE5NiBaIgogICAgICAgY29weXR5cGU9InNpbmdsZV9zdHJldGNoZWQiCiAgICAgICBwcm9wX3NjYWxlPSIxIgogICAgICAgc2NhbGVfeV9yZWw9ImZhbHNlIgogICAgICAgc3BhY2luZz0iMCIKICAgICAgIG5vcm1hbF9vZmZzZXQ9IjAiCiAgICAgICB0YW5nX29mZnNldD0iMCIKICAgICAgIHByb3BfdW5pdHM9ImZhbHNlIgogICAgICAgdmVydGljYWxfcGF0dGVybj0iZmFsc2UiCiAgICAgICBoaWRlX2tub3Q9ImZhbHNlIgogICAgICAgZnVzZV90b2xlcmFuY2U9IjAiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic2tlbGV0YWwiCiAgICAgICBpZD0icGF0aC1lZmZlY3QxNTgiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Im0gMTcyLjM1NzE0LDM1LjUyOTc2IGMgOTIuOTgyMTMsLTE2LjYzMDk1MSAxMDUuODMzMzQsLTMyLjUwNTk1MDYgOTIuMjI2MTksLTE3LjM4NjkwMyAtMTMuNjA3MTQsMTUuMTE5MDQ4IC01NS45NDA0OCwyMS4xNjY2NjcgLTEzLjYwNzE0LDE0LjM2MzA5NCA0Mi4zMzMzMiwtNi44MDM1NyAxMTQuMTQ4ODEsLTUuMjkxNjY2IDYzLjQ5OTk5LDEuNTExOTA2IC01MC42NDg4LDYuODAzNTcgLTIwLjQxMDcsMTguODk4ODA5IC0yMC40MTA3LDE4Ljg5ODgwOSAwLDAgMTAzLjU2NTQ2LDMwLjIzODA5NCAtMTIxLjcwODM0LC0xNy4zODY5MDYgeiIKICAgICAgIGNvcHl0eXBlPSJzaW5nbGVfc3RyZXRjaGVkIgogICAgICAgcHJvcF9zY2FsZT0iMSIKICAgICAgIHNjYWxlX3lfcmVsPSJmYWxzZSIKICAgICAgIHNwYWNpbmc9IjAiCiAgICAgICBub3JtYWxfb2Zmc2V0PSIwIgogICAgICAgdGFuZ19vZmZzZXQ9IjAiCiAgICAgICBwcm9wX3VuaXRzPSJmYWxzZSIKICAgICAgIHZlcnRpY2FsX3BhdHRlcm49ImZhbHNlIgogICAgICAgaGlkZV9rbm90PSJmYWxzZSIKICAgICAgIGZ1c2VfdG9sZXJhbmNlPSIwIiAvPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNrZWxldGFsIgogICAgICAgaWQ9InBhdGgtZWZmZWN0MTQ1IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDEzMiIKICAgICAgIGlzX3Zpc2libGU9InRydWUiCiAgICAgICBscGV2ZXJzaW9uPSIxIgogICAgICAgcGF0dGVybj0ibSAxNzIuMzU3MTQsMzUuNTI5NzYgYyA5Mi45ODIxMywtMTYuNjMwOTUxIDEwNS44MzMzNCwtMzIuNTA1OTUwNiA5Mi4yMjYxOSwtMTcuMzg2OTAzIC0xMy42MDcxNCwxNS4xMTkwNDggLTU1Ljk0MDQ4LDIxLjE2NjY2NyAtMTMuNjA3MTQsMTQuMzYzMDk0IDQyLjMzMzMyLC02LjgwMzU3IDExNC4xNDg4MSwtNS4yOTE2NjYgNjMuNDk5OTksMS41MTE5MDYgLTUwLjY0ODgsNi44MDM1NyAtMjAuNDEwNywxOC44OTg4MDkgLTIwLjQxMDcsMTguODk4ODA5IDAsMCAxMDMuNTY1NDYsMzAuMjM4MDk0IC0xMjEuNzA4MzQsLTE3LjM4NjkwNiB6IgogICAgICAgY29weXR5cGU9InNpbmdsZV9zdHJldGNoZWQiCiAgICAgICBwcm9wX3NjYWxlPSIxIgogICAgICAgc2NhbGVfeV9yZWw9ImZhbHNlIgogICAgICAgc3BhY2luZz0iMCIKICAgICAgIG5vcm1hbF9vZmZzZXQ9IjAiCiAgICAgICB0YW5nX29mZnNldD0iMCIKICAgICAgIHByb3BfdW5pdHM9ImZhbHNlIgogICAgICAgdmVydGljYWxfcGF0dGVybj0iZmFsc2UiCiAgICAgICBoaWRlX2tub3Q9ImZhbHNlIgogICAgICAgZnVzZV90b2xlcmFuY2U9IjAiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0ic2tlbGV0YWwiCiAgICAgICBpZD0icGF0aC1lZmZlY3QxMTkiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIHBhdHRlcm49Im0gMTcyLjM1NzE0LDM1LjUyOTc2IGMgOTIuOTgyMTMsLTE2LjYzMDk1MSAxMDUuODMzMzQsLTMyLjUwNTk1MDYgOTIuMjI2MTksLTE3LjM4NjkwMyAtMTMuNjA3MTQsMTUuMTE5MDQ4IC01NS45NDA0OCwyMS4xNjY2NjcgLTEzLjYwNzE0LDE0LjM2MzA5NCA0Mi4zMzMzMiwtNi44MDM1NyAxMTQuMTQ4ODEsLTUuMjkxNjY2IDYzLjQ5OTk5LDEuNTExOTA2IC01MC42NDg4LDYuODAzNTcgLTIwLjQxMDcsMTguODk4ODA5IC0yMC40MTA3LDE4Ljg5ODgwOSAwLDAgMTAzLjU2NTQ2LDMwLjIzODA5NCAtMTIxLjcwODM0LC0xNy4zODY5MDYgeiIKICAgICAgIGNvcHl0eXBlPSJzaW5nbGVfc3RyZXRjaGVkIgogICAgICAgcHJvcF9zY2FsZT0iMSIKICAgICAgIHNjYWxlX3lfcmVsPSJmYWxzZSIKICAgICAgIHNwYWNpbmc9IjAiCiAgICAgICBub3JtYWxfb2Zmc2V0PSIwIgogICAgICAgdGFuZ19vZmZzZXQ9IjAiCiAgICAgICBwcm9wX3VuaXRzPSJmYWxzZSIKICAgICAgIHZlcnRpY2FsX3BhdHRlcm49ImZhbHNlIgogICAgICAgaGlkZV9rbm90PSJmYWxzZSIKICAgICAgIGZ1c2VfdG9sZXJhbmNlPSIwIiAvPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InNrZWxldGFsIgogICAgICAgaWQ9InBhdGgtZWZmZWN0MTA2IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDkzIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDgwIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDY3IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJza2VsZXRhbCIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDU0IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBwYXR0ZXJuPSJtIDE3Mi4zNTcxNCwzNS41Mjk3NiBjIDkyLjk4MjEzLC0xNi42MzA5NTEgMTA1LjgzMzM0LC0zMi41MDU5NTA2IDkyLjIyNjE5LC0xNy4zODY5MDMgLTEzLjYwNzE0LDE1LjExOTA0OCAtNTUuOTQwNDgsMjEuMTY2NjY3IC0xMy42MDcxNCwxNC4zNjMwOTQgNDIuMzMzMzIsLTYuODAzNTcgMTE0LjE0ODgxLC01LjI5MTY2NiA2My40OTk5OSwxLjUxMTkwNiAtNTAuNjQ4OCw2LjgwMzU3IC0yMC40MTA3LDE4Ljg5ODgwOSAtMjAuNDEwNywxOC44OTg4MDkgMCwwIDEwMy41NjU0NiwzMC4yMzgwOTQgLTEyMS43MDgzNCwtMTcuMzg2OTA2IHoiCiAgICAgICBjb3B5dHlwZT0ic2luZ2xlX3N0cmV0Y2hlZCIKICAgICAgIHByb3Bfc2NhbGU9IjEiCiAgICAgICBzY2FsZV95X3JlbD0iZmFsc2UiCiAgICAgICBzcGFjaW5nPSIwIgogICAgICAgbm9ybWFsX29mZnNldD0iMCIKICAgICAgIHRhbmdfb2Zmc2V0PSIwIgogICAgICAgcHJvcF91bml0cz0iZmFsc2UiCiAgICAgICB2ZXJ0aWNhbF9wYXR0ZXJuPSJmYWxzZSIKICAgICAgIGhpZGVfa25vdD0iZmFsc2UiCiAgICAgICBmdXNlX3RvbGVyYW5jZT0iMCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJwb3dlcnN0cm9rZSIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDQxIgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBvZmZzZXRfcG9pbnRzPSIwLDAuMTMyMjkxNSIKICAgICAgIHNvcnRfcG9pbnRzPSJ0cnVlIgogICAgICAgaW50ZXJwb2xhdG9yX3R5cGU9IkN1YmljQmV6aWVySm9oYW4iCiAgICAgICBpbnRlcnBvbGF0b3JfYmV0YT0iMC4yIgogICAgICAgc3RhcnRfbGluZWNhcF90eXBlPSJ6ZXJvd2lkdGgiCiAgICAgICBsaW5lam9pbl90eXBlPSJleHRycF9hcmMiCiAgICAgICBtaXRlcl9saW1pdD0iNCIKICAgICAgIHNjYWxlX3dpZHRoPSIxIgogICAgICAgZW5kX2xpbmVjYXBfdHlwZT0iemVyb3dpZHRoIiAvPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InBvd2Vyc3Ryb2tlIgogICAgICAgaWQ9InBhdGgtZWZmZWN0MzciCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIG9mZnNldF9wb2ludHM9IjAsMC4xMzIyOTE1IgogICAgICAgc29ydF9wb2ludHM9InRydWUiCiAgICAgICBpbnRlcnBvbGF0b3JfdHlwZT0iQ3ViaWNCZXppZXJKb2hhbiIKICAgICAgIGludGVycG9sYXRvcl9iZXRhPSIwLjIiCiAgICAgICBzdGFydF9saW5lY2FwX3R5cGU9Inplcm93aWR0aCIKICAgICAgIGxpbmVqb2luX3R5cGU9ImV4dHJwX2FyYyIKICAgICAgIG1pdGVyX2xpbWl0PSI0IgogICAgICAgc2NhbGVfd2lkdGg9IjEiCiAgICAgICBlbmRfbGluZWNhcF90eXBlPSJ6ZXJvd2lkdGgiIC8+CiAgICA8aW5rc2NhcGU6cGF0aC1lZmZlY3QKICAgICAgIGVmZmVjdD0icG93ZXJzdHJva2UiCiAgICAgICBpZD0icGF0aC1lZmZlY3QzMyIKICAgICAgIGlzX3Zpc2libGU9InRydWUiCiAgICAgICBscGV2ZXJzaW9uPSIxIgogICAgICAgb2Zmc2V0X3BvaW50cz0iMCwwLjEzMjI5MTUiCiAgICAgICBzb3J0X3BvaW50cz0idHJ1ZSIKICAgICAgIGludGVycG9sYXRvcl90eXBlPSJDdWJpY0JlemllckpvaGFuIgogICAgICAgaW50ZXJwb2xhdG9yX2JldGE9IjAuMiIKICAgICAgIHN0YXJ0X2xpbmVjYXBfdHlwZT0iemVyb3dpZHRoIgogICAgICAgbGluZWpvaW5fdHlwZT0iZXh0cnBfYXJjIgogICAgICAgbWl0ZXJfbGltaXQ9IjQiCiAgICAgICBzY2FsZV93aWR0aD0iMSIKICAgICAgIGVuZF9saW5lY2FwX3R5cGU9Inplcm93aWR0aCIgLz4KICAgIDxpbmtzY2FwZTpwYXRoLWVmZmVjdAogICAgICAgZWZmZWN0PSJwb3dlcnN0cm9rZSIKICAgICAgIGlkPSJwYXRoLWVmZmVjdDE2IgogICAgICAgaXNfdmlzaWJsZT0idHJ1ZSIKICAgICAgIGxwZXZlcnNpb249IjEiCiAgICAgICBvZmZzZXRfcG9pbnRzPSIwLDAuMTMyMjkxNSIKICAgICAgIHNvcnRfcG9pbnRzPSJ0cnVlIgogICAgICAgaW50ZXJwb2xhdG9yX3R5cGU9IkN1YmljQmV6aWVySm9oYW4iCiAgICAgICBpbnRlcnBvbGF0b3JfYmV0YT0iMC4yIgogICAgICAgc3RhcnRfbGluZWNhcF90eXBlPSJ6ZXJvd2lkdGgiCiAgICAgICBsaW5lam9pbl90eXBlPSJleHRycF9hcmMiCiAgICAgICBtaXRlcl9saW1pdD0iNCIKICAgICAgIHNjYWxlX3dpZHRoPSIxIgogICAgICAgZW5kX2xpbmVjYXBfdHlwZT0iemVyb3dpZHRoIiAvPgogICAgPGlua3NjYXBlOnBhdGgtZWZmZWN0CiAgICAgICBlZmZlY3Q9InBvd2Vyc3Ryb2tlIgogICAgICAgaWQ9InBhdGgtZWZmZWN0MTIiCiAgICAgICBpc192aXNpYmxlPSJ0cnVlIgogICAgICAgbHBldmVyc2lvbj0iMSIKICAgICAgIG9mZnNldF9wb2ludHM9IjAsMC4xMzIyOTE1IgogICAgICAgc29ydF9wb2ludHM9InRydWUiCiAgICAgICBpbnRlcnBvbGF0b3JfdHlwZT0iQ3ViaWNCZXppZXJKb2hhbiIKICAgICAgIGludGVycG9sYXRvcl9iZXRhPSIwLjIiCiAgICAgICBzdGFydF9saW5lY2FwX3R5cGU9Inplcm93aWR0aCIKICAgICAgIGxpbmVqb2luX3R5cGU9ImV4dHJwX2FyYyIKICAgICAgIG1pdGVyX2xpbWl0PSI0IgogICAgICAgc2NhbGVfd2lkdGg9IjEiCiAgICAgICBlbmRfbGluZWNhcF90eXBlPSJ6ZXJvd2lkdGgiIC8+CiAgICA8bGluZWFyR3JhZGllbnQKICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgIHhsaW5rOmhyZWY9IiNsaW5lYXJHcmFkaWVudDE0MDUiCiAgICAgICBpZD0ibGluZWFyR3JhZGllbnQxNDA3IgogICAgICAgeDE9IjkuMzkzOTU1MiIKICAgICAgIHkxPSI3LjI4MDMxNDkiCiAgICAgICB4Mj0iMjI1LjY4OTc2IgogICAgICAgeTI9Ijk4Ljg3MTM3NiIKICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiAvPgogICAgPGZpbHRlcgogICAgICAgaW5rc2NhcGU6Y29sbGVjdD0iYWx3YXlzIgogICAgICAgc3R5bGU9ImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyczpzUkdCIgogICAgICAgaWQ9ImZpbHRlcjM0MjIiCiAgICAgICB4PSItMC4wNTIzMDM1MDIiCiAgICAgICB3aWR0aD0iMS4xMDQ2MDciCiAgICAgICB5PSItMC4xODA2NDcxNCIKICAgICAgIGhlaWdodD0iMS4zNjEyOTQzIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyCiAgICAgICAgIGlua3NjYXBlOmNvbGxlY3Q9ImFsd2F5cyIKICAgICAgICAgc3RkRGV2aWF0aW9uPSI0Ljc2NjMzMyIKICAgICAgICAgaWQ9ImZlR2F1c3NpYW5CbHVyMzQyNCIgLz4KICAgIDwvZmlsdGVyPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMS4xMjY2MTEiCiAgICAgaW5rc2NhcGU6Y3g9IjQ0Ny4yNDc4NCIKICAgICBpbmtzY2FwZTpjeT0iMzg1Ljk4MTc3IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJtbSIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtcm90YXRpb249IjAiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIHVuaXRzPSJweCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE3MTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAzNSIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMjM0IgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyMyIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIwIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDEyMzQiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOnVybCgjbGluZWFyR3JhZGllbnQxNDA3KTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzFmMjQxYztzdHJva2Utd2lkdGg6MTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZSIKICAgICAgIGlkPSJyZWN0MTM5OSIKICAgICAgIHdpZHRoPSIyMzcuNDMyMjEiCiAgICAgICBoZWlnaHQ9IjEwNy41NjA3OCIKICAgICAgIHg9Ii0wLjkzOTM5NTQ5IgogICAgICAgeT0iLTAuMjM0ODQ4ODciIC8+CiAgICA8ZwogICAgICAgaWQ9ImczMzIwIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS4yOTE2NjY5LC0xMC41ODMzMzQpIgogICAgICAgc3R5bGU9ImZpbGw6I2Y2ZmZkNTtmaWx0ZXI6dXJsKCNmaWx0ZXIzNDIyKSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzMxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6I2Y2ZmZkNTtzdHJva2U6IzFmMjQxYztzdHJva2Utd2lkdGg6MC4yMDk3NzhweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJtIDE3MC40MTYzNywzMS45NjU1ODggYyAtNi4yNDM5Nyw1LjA3NDE0MSAtMTIuMDk3MTYsMTAuMTc5ODggLTE4LjE2ODgxLDE0Ljk2MzMzMSAtNS41MDkyNyw0LjMxODk0OSAtMTEuMTE5ODYsOC4zODEyNTYgLTE3LjM4Nzc2LDExLjU5NDUwMiAtMy42OTkyNCwxLjkwNDk2IC03LjY3Njc2LDMuNTIzMTc3IC0xMS44NTE3Myw0Ljc1NjM5NSA0LjA2NTk5LC0xLjQ5NjA3NyA3Ljg1MjIzLC0zLjM1NzczNyAxMS4zMDI4LC01LjQ2OTU0OSA1Ljg2MjU3LC0zLjU2MzcyNSAxMC45NDA4LC03LjkwOTE0IDE1Ljk3OTY2LC0xMi41MTUzNjEgMC43OTQ5NSwtMC43MzE4NDIgMS41ODU0NiwtMS40NzA1NzIgMi4zNzM5OSwtMi4yMTUxNTYgLTAuODM1NDQsMC43MDY0MjkgLTEuNjcyNDksMS40MDY1OTEgLTIuNTEyOTgsMi4wOTkyODYgLTUuMzI3MDgsNC4zNTgxMjMgLTEwLjY1ODg4LDguNDI4NTAzIC0xNi42MDQ4NiwxMS42Mzg5ODMgLTUuNzQ5OTcsMy4xMjgyMjQgLTEyLjI1MDc5LDUuNTM4OTE4IC0xOS4xNzU0LDYuNzcxMDIzIC04LjQxMTksMS41NDY3MiAtMTcuNjQxMjMxLDEuNDE3NzQgLTI2LjgxOTYzOCwwLjM3MTI4NSA0LjUyMTY4NCwxLjM1ODE2MyA5LjIwMjU1MywyLjQ5OTY5MyAxNC4wMjIxNDgsMy4yODE2NTkgMC4wODgxLDUuNTIwMTIxIDIuMzU5NiwxMS4zMzE4MiA3LjIwMzQxLDE2LjE0MzE5MyA0LjY3Mzc3LDQuNjM5MzE2IDExLjU0MDI3LDguMjc4NjQ4IDE5LjQzOTgxLDEwLjIyNzAyNCA3Ljk4MDU5LDEuOTc4NjMgMTYuOTgwMTUsMi4yODA2OCAyNS43OTI5MiwwLjUwNjUyNiA2LjA0NTA1LC0xLjI0MzQ3NiAxMS44Mzk2NywtMy40NTYzMzkgMTYuOTY2MTMsLTYuNTIyNzgxIC01LjIyMjcyLDIuOTkzMTUxIC0xMS4wNzY1MSw1LjEwNDMxMiAtMTcuMTIxMDMsNi4yMzQzNjMgLTguODE0NTQsMS42MTA2MDIgLTE3LjcwNzAzLDEuMTI3ODg5IC0yNS40Njg2MiwtMC45NzY0NjMgLTUuMTA4NzgsLTEuMzgwMDI2IC05LjcxNzYsLTMuNDgyODE2IC0xMy40OTE5NCwtNi4wODIyNjEgNC4yNDI1NCwyLjAxNDc3NyA5LjAxNzg1LDMuMzg4NDE5IDEzLjk0NTg3LDQuMDUxODUgMCwwIDQuOGUtNCwwIDQuOGUtNCwwIDcuNDk1MywxLjAwOTE5NyAxNS4zNzA3NSwwLjQwNDExOSAyMi40Mzg1MywtMS43OTY4NzYgNC40MDc0NCwtMS4zNzI5NzQgOC40NjA1OCwtMy4zODc1NjEgMTEuOTQxMTEsLTUuODc4ODYxIC0zLjU5NzcxLDIuMzk1ODgyIC03LjcyMzgyLDQuMjgzMjA0IC0xMi4xMzYyNSw1LjUxNTEwOSAtNy4wNzkwMSwxLjk3ODExIC0xNC44MTU2MywyLjMzNTI5MyAtMjIuMDE3ODMsMS4xNTE1MjIgLTMuMzU1NDQsLTAuNTUyOTc0IC02LjYwNDYsLTEuNDQ1ODk1IC05LjYxNDg0LC0yLjY0Mjc2MSAzLjIzMDczLDAuODM0OTg0IDYuNTcyMjUsMS4zMTg4MjggOS44Nzg3NywxLjQ2MTgyNCA3LjEwMjMsMC4zMDEyNDQgMTQuMTIyNTksLTAuOTU3NzU3IDE5Ljg4NTMxLC0zLjQ1NTY0NCA1Ljc1MTk5LC0yLjQ3MjkyMyAxMC4zMjE4OSwtNi4yODY1NTQgMTMuMDk5NzksLTEwLjUyMzY5MiA2LjI3OTgxLDEuNzE3MDIxIDEyLjk5MjI2LDIuODUyODE1IDIwLjA1MzMxLDMuMDI3Njc4IDcuNzYwOTUsMC4xODk5OTMgMTUuOTA5NTksLTAuOTIyNjgzIDIzLjYwOTM4LC0zLjgyODM2MyA1LjI0NjU2LC0yLjA0MjU2NCAxMC4wMjMzOSwtNC44Mjk5NSAxNC4xMjc5MiwtOC4xNTI0OSAtNC4yMTE0NCwzLjI2MzcwNSAtOS4wNzA2LDUuOTY2NDk3IC0xNC4zNTAyLDcuOTAyNDU1IC03Ljc0NjEsMi43NTQxMDcgLTE1Ljg1NDIzLDMuNjg0ODg2IC0yMy41MDMxNiwzLjMzOTc3NCAtNS42MjU4NywtMC4yNTU0NCAtMTAuOTk1NTIsLTEuMTMyOTIgLTE2LjA3OTgsLTIuNDI1MzcxIDUuMjEzNjcsMC41NTM4MDcgMTAuNTAyODMsMC42NzIzMzUgMTUuNzMyMSwwLjIwNzcwNCA3LjA4Njc1LC0wLjYyOTY0MyAxNC4wNTc5MiwtMi40MDE0NzggMTkuOTg3NzksLTUuNDY5MTkxIDMuNjk4MDIsLTEuOTE0Mzc3IDYuOTMwODIsLTQuMzE1NjM3IDkuNjUyNzUsLTcuMDMwMzg1IC0yLjg1MzQxLDIuNjM3OTcxIC02LjE4NzU1LDQuOTMzNDU1IC05LjkzMTY2LDYuNzE2NDk1IC02LjAwMTMyLDIuODYyMzM2IC0xMi45MjM4OCw0LjM4NTA4OCAtMTkuODYyODQsNC44MDEyMzkgLTMuNzUxODEsMC4yMjQ4OTkgLTcuNTEzODMsMC4xNDAxMDggLTExLjI0MTUsLTAuMTkxNTYyIDMuNzY5OTYsLTAuMTEzOTE4IDcuNDczNzQsLTAuNDc4OTQyIDExLjAzMjc5LC0xLjEzODk2NiA2LjU2NzA3LC0xLjIyMTUxNSAxMi42NTE5NiwtMy40NjE1MiAxNy4yNjQyMiwtNi42Mjk2ODQgNS4wMTM0MiwtMy4zNjM4NDMgOC40NzY5OSwtNy45MDM2MTMgMTAuNTU5NjYsLTEyLjY1NzA1OSAtMi40MTE2MSw0LjYzMjQxIC02LjEzNjIsOC45MzMwNCAtMTEuMTc1NTEsMTEuOTYzNjM0IC00LjYzMDc4LDIuODcxMzAxIC0xMC41ODUzNCw0Ljc3NDA5NCAtMTYuODk5NjgsNS43MTkyMjcgLTMuOTE2NiwwLjU4MzM0NSAtNy45ODk2NSwwLjc4ODkyMyAtMTIuMTE3NTMsMC42OTA5MTMgNC4xNjM4NiwtMC4xODY1NTcgOC4yMDE5OCwtMC42ODEyNTYgMTEuOTg0MTYsLTEuNTQyMTc4IDYuMDg2NjUsLTEuMzk1MzEyIDExLjU1MTE0LC0zLjY5NDI4NiAxNS4zODE1OSwtNi43MjY1NCAwLjUyNzc4LC0wLjM5OTQ2MSAxLjAzMTcyLC0wLjgxNTYzMiAxLjUxMjk0LC0xLjI0Njk0NCAtMC41MTc5MiwwLjM5NjA2NSAtMS4wNTUzMSwwLjc3NDk4MSAtMS42MTI2MSwxLjEzNTAyMSAtNC4wNDY1LDIuNzQ0NTM4IC05LjUyNTIxLDQuNjYzMTE2IC0xNS40NTgzNCw1LjcxNTI4IC02LjM2MDc3LDEuMTE4NTY2IC0xMy4zMjU2MiwxLjE1OTYxNiAtMjAuMzM1OTYsMC40NzY3NTMgLTcuNDM3NDQsLTAuNzM3NjE1IC0xNC44NzIxNiwtMi4zNDEwNjQgLTIyLjA0NTkxLC00LjYxNzU2OSA2LjI0NzY5LDMuNjMwNjg1IDEzLjE2Nzk1LDYuNzU5NjUgMjAuNzI1Myw5LjA5MTI4NiAwLjk2NTI5LDAuMjk3ODk1IDEuOTQyNCwwLjU4MTc0IDIuOTI5NDcsMC44NTIzNDEgLTMuMDYxMTcsNC4wNzMwMzYgLTcuNzkzNjMsNy41OTU1MTQgLTEzLjQ2MzM5LDkuNzQ4MTE5IC01LjY5MzA4LDIuMTg4MTMzIC0xMi40NTEyNiwzLjEyMzk5OCAtMTkuMDk0NDUsMi42MTE1NTIgLTMuNTc2ODcsLTAuMjgxODI2IC03LjE1MTcxLC0wLjk4NTM0OCAtMTAuNTA0NDUsLTIuMTAzOTUgMy41MDg4OCwwLjg4ODc5MiA3LjE0NDYzLDEuMzIzNjUgMTAuNjc1NzMsMS4zMzc3MDUgNi41NjE2NCwwLjAxNDM2IDEyLjg5MzMsLTEuNDI1MDUgMTcuODIzNDQsLTMuODk2ODgxIDAuNzQzNDQsLTAuMzY3OTA3IDEuNDU5NDMsLTAuNzYyNTcyIDIuMTQ2NTcsLTEuMTgwOTM5IC0wLjcxODg0LDAuMzcxOTUgLTEuNDYxMTUsMC43MTgxOTEgLTIuMjI0NzIsMS4wMzU2NTMgLTUuMDYzMzUsMi4xNDI2MDYgLTExLjI4MzcyLDMuMTg2MTE0IC0xNy40ODMyMywyLjg3MDkxMyAtNi4xMDMyLC0wLjMyNjA0OCAtMTIuMzMwMDYsLTEuOTY0NTY3IC0xNy4zMTEwMiwtNC45NDUwODcgLTUuMTQ3NiwtMi45OTYzMDggLTkuMDQ1MDgsLTcuNjM3NTAxIC0xMC45ODUwNSwtMTIuODMxNDAxIDQuMzczMTYsMC42OTY5NTEgOC44NTk5MywxLjA5NzU2IDEzLjQ0OTgzLDEuMDgyNjQ2IDguMDcxNjIsLTAuMDMwMjYgMTYuMzI4NTIsLTEuNDI1NTM3IDI0LjExNDc5LC0zLjk0NzgyIDcuODkxNiwtMi41NTkxNzggMTUuMjUxMjUsLTYuMDY1Nzg5IDIyLjEzNDM1LC05LjczODA3NSA0Ljg3MzA1LC0yLjU4NDAxOCA5LjU5NTAzLC01LjI1NTU1IDE0LjI0MDIzLC03Ljg1OTQwOCAtNC43NDAwMSwyLjUyOTQ0MiAtOS41NTcwNCw1LjEyNjczMiAtMTQuNTE1MzksNy42Mjk0NjEgLTcuMDA0MjIsMy41NTYzMzggLTE0LjQ1ODYxLDYuOTMxMTY3IC0yMi4zNTg1MSw5LjMxOTQzOSAtNS42OTIyOCwxLjcxOTg4OSAtMTEuNTk1MTUsMi44Mjk5NzUgLTE3LjQzNzg1LDMuMjQ3MjIxIDUuNjAyMjMsLTEuMTE1OTQ3IDEwLjk5MzQ2LC0yLjg3MDc3NSAxNS45OTg4NSwtNS4xMTYyMDIgNi45NzQ1NiwtMy4xMjg5NDIgMTMuMjQzOTUsLTcuMTAzNzUyIDE5LjIxNDcxLC0xMS4yNzU5NSAzLjg1Nzc3LC0yLjY5NTM4IDcuNjA4MDgsLTUuNDc3Njc4IDExLjM1MzgxLC04LjI2MTU0NCAtMy44NjUyMSwyLjY5MDA5NCAtNy43MzQ1OSw1LjM3ODI0IC0xMS43MDA1Nyw3Ljk3MTY5IC02LjEzODg1LDQuMDEzMTg4IC0xMi41NDE1OCw3LjgwNzY1MSAtMTkuNTMyLDEwLjcwMzA1OCAtMy42MjMxNiwxLjUwMTgyMiAtNy40MTkyNiwyLjc0MTg1MSAtMTEuMzE0MDMsMy42NjgzNyAzLjcwOTA1LC0xLjMzMTM4NiA3LjIxMDU1LC0yLjk0NzgyNyAxMC40NTk5OSwtNC43Nzc1NjEgNi4yODk3NCwtMy41MzE3MzUgMTEuNzU2MjQsLTcuODM5MDg4IDE3LjA2MTEzLC0xMi4zNjkzNTcgNS44NDc1NCwtNS4wMTM2NjMgMTEuNDI2MSwtMTAuMzEyNzI1IDE3LjQxMzUxLC0xNS41OTM2MiB6IiAvPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDMzMTgiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNmNmZmZDU7c3Ryb2tlOiMxZjI0MWM7c3Ryb2tlLXdpZHRoOjAuMjA5Nzc4cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0ibSA1MS4wODc1NzQsMzEuOTY1NTg4IGMgNi4yNDM5Nyw1LjA3NDE0MSAxMi4wOTcxNiwxMC4xNzk4OCAxOC4xNjg4MSwxNC45NjMzMzEgNS41MDkyNyw0LjMxODk0OSAxMS4xMTk4Niw4LjM4MTI1NiAxNy4zODc3NiwxMS41OTQ1MDIgMy42OTkyNCwxLjkwNDk2IDcuNjc2NzYsMy41MjMxNzcgMTEuODUxNzMsNC43NTYzOTUgLTQuMDY1OTksLTEuNDk2MDc3IC03Ljg1MjIzLC0zLjM1NzczNyAtMTEuMzAyOCwtNS40Njk1NDkgLTUuODYyNTcsLTMuNTYzNzI1IC0xMC45NDA4LC03LjkwOTE0IC0xNS45Nzk2NiwtMTIuNTE1MzYxIC0wLjc5NDk1LC0wLjczMTg0MiAtMS41ODU0NiwtMS40NzA1NzIgLTIuMzczOTksLTIuMjE1MTU2IDAuODM1NDQsMC43MDY0MjkgMS42NzI0OSwxLjQwNjU5MSAyLjUxMjk4LDIuMDk5Mjg2IDUuMzI3MDgsNC4zNTgxMjMgMTAuNjU4ODgsOC40Mjg1MDMgMTYuNjA0ODYsMTEuNjM4OTgzIDUuNzQ5OTcsMy4xMjgyMjQgMTIuMjUwNzg2LDUuNTM4OTE4IDE5LjE3NTM5Niw2Ljc3MTAyMyA4LjQxMTksMS41NDY3MiAxNy42NDEyMywxLjQxNzc0IDI2LjgxOTY0LDAuMzcxMjg1IC00LjUyMTY4LDEuMzU4MTYzIC05LjIwMjU1LDIuNDk5NjkzIC0xNC4wMjIxNSwzLjI4MTY1OSAtMC4wODgxLDUuNTIwMTIxIC0yLjM1OTYsMTEuMzMxODIgLTcuMjAzNDEsMTYuMTQzMTkzIC00LjY3Mzc3LDQuNjM5MzE2IC0xMS41NDAyNyw4LjI3ODY0OCAtMTkuNDM5ODA2LDEwLjIyNzAyNCAtNy45ODA1OSwxLjk3ODYzIC0xNi45ODAxNSwyLjI4MDY4IC0yNS43OTI5MiwwLjUwNjUyNiAtNi4wNDUwNSwtMS4yNDM0NzYgLTExLjgzOTY3LC0zLjQ1NjMzOSAtMTYuOTY2MTMsLTYuNTIyNzgxIDUuMjIyNzIsMi45OTMxNTEgMTEuMDc2NTEsNS4xMDQzMTIgMTcuMTIxMDMsNi4yMzQzNjMgOC44MTQ1NCwxLjYxMDYwMiAxNy43MDcwMywxLjEyNzg4OSAyNS40Njg2MiwtMC45NzY0NjMgNS4xMDg3OCwtMS4zODAwMjYgOS43MTc1OTYsLTMuNDgyODE2IDEzLjQ5MTkzNiwtNi4wODIyNjEgLTQuMjQyNTQsMi4wMTQ3NzcgLTkuMDE3ODQ2LDMuMzg4NDE5IC0xMy45NDU4NjYsNC4wNTE4NSAwLDAgLTQuOGUtNCwwIC00LjhlLTQsMCAtNy40OTUzLDEuMDA5MTk3IC0xNS4zNzA3NSwwLjQwNDExOSAtMjIuNDM4NTMsLTEuNzk2ODc2IC00LjQwNzQ0LC0xLjM3Mjk3NCAtOC40NjA1OCwtMy4zODc1NjEgLTExLjk0MTExLC01Ljg3ODg2MSAzLjU5NzcxLDIuMzk1ODgyIDcuNzIzODIsNC4yODMyMDQgMTIuMTM2MjUsNS41MTUxMDkgNy4wNzkwMSwxLjk3ODExIDE0LjgxNTYzLDIuMzM1MjkzIDIyLjAxNzgzLDEuMTUxNTIyIDMuMzU1NDQsLTAuNTUyOTc0IDYuNjA0NiwtMS40NDU4OTUgOS42MTQ4MzYsLTIuNjQyNzYxIC0zLjIzMDcyNiwwLjgzNDk4NCAtNi41NzIyNDYsMS4zMTg4MjggLTkuODc4NzY2LDEuNDYxODI0IC03LjEwMjMsMC4zMDEyNDQgLTE0LjEyMjU5LC0wLjk1Nzc1NyAtMTkuODg1MzEsLTMuNDU1NjQ0IC01Ljc1MTk5LC0yLjQ3MjkyMyAtMTAuMzIxODksLTYuMjg2NTU0IC0xMy4wOTk3OSwtMTAuNTIzNjkyIC02LjI3OTgxLDEuNzE3MDIxIC0xMi45OTIyNiwyLjg1MjgxNSAtMjAuMDUzMzEsMy4wMjc2NzggLTcuNzYwOTUsMC4xODk5OTMgLTE1LjkwOTU5LC0wLjkyMjY4MyAtMjMuNjA5MzgsLTMuODI4MzYzIC01LjI0NjU1OCwtMi4wNDI1NjQgLTEwLjAyMzM4ODMsLTQuODI5OTUgLTE0LjEyNzkxODMsLTguMTUyNDkgNC4yMTE0NCwzLjI2MzcwNSA5LjA3MDYwMDMsNS45NjY0OTcgMTQuMzUwMTk4Myw3LjkwMjQ1NSA3Ljc0NjEsMi43NTQxMDcgMTUuODU0MjMsMy42ODQ4ODYgMjMuNTAzMTYsMy4zMzk3NzQgNS42MjU4NywtMC4yNTU0NCAxMC45OTU1MiwtMS4xMzI5MiAxNi4wNzk4LC0yLjQyNTM3MSAtNS4yMTM2NywwLjU1MzgwNyAtMTAuNTAyODMsMC42NzIzMzUgLTE1LjczMjEsMC4yMDc3MDQgLTcuMDg2NzUsLTAuNjI5NjQzIC0xNC4wNTc5MiwtMi40MDE0NzggLTE5Ljk4Nzc5LC01LjQ2OTE5MSAtMy42OTgwMiwtMS45MTQzNzcgLTYuOTMwODE4LC00LjMxNTYzNyAtOS42NTI3NDgzLC03LjAzMDM4NSAyLjg1MzQxMDMsMi42Mzc5NzEgNi4xODc1NDgzLDQuOTMzNDU1IDkuOTMxNjU4Myw2LjcxNjQ5NSA2LjAwMTMyLDIuODYyMzM2IDEyLjkyMzg4LDQuMzg1MDg4IDE5Ljg2Mjg0LDQuODAxMjM5IDMuNzUxODEsMC4yMjQ4OTkgNy41MTM4MywwLjE0MDEwOCAxMS4yNDE1LC0wLjE5MTU2MiAtMy43Njk5NiwtMC4xMTM5MTggLTcuNDczNzQsLTAuNDc4OTQyIC0xMS4wMzI3OSwtMS4xMzg5NjYgLTYuNTY3MDcsLTEuMjIxNTE1IC0xMi42NTE5NiwtMy40NjE1MiAtMTcuMjY0MjIsLTYuNjI5Njg0IC01LjAxMzQyLC0zLjM2Mzg0MyAtOC40NzY5OSwtNy45MDM2MTMgLTEwLjU1OTY1OCwtMTIuNjU3MDU5IDIuNDExNjA4LDQuNjMyNDEgNi4xMzYxOTgsOC45MzMwNCAxMS4xNzU1MDgsMTEuOTYzNjM0IDQuNjMwNzgsMi44NzEzMDEgMTAuNTg1MzQsNC43NzQwOTQgMTYuODk5NjgsNS43MTkyMjcgMy45MTY2LDAuNTgzMzQ1IDcuOTg5NjUsMC43ODg5MjMgMTIuMTE3NTMsMC42OTA5MTMgLTQuMTYzODYsLTAuMTg2NTU3IC04LjIwMTk4LC0wLjY4MTI1NiAtMTEuOTg0MTYsLTEuNTQyMTc4IC02LjA4NjY1LC0xLjM5NTMxMiAtMTEuNTUxMTQsLTMuNjk0Mjg2IC0xNS4zODE1OSwtNi43MjY1NCAtMC41Mjc3OCwtMC4zOTk0NjEgLTEuMDMxNzIsLTAuODE1NjMyIC0xLjUxMjk0LC0xLjI0Njk0NCAwLjUxNzkyLDAuMzk2MDY1IDEuMDU1MzEsMC43NzQ5ODEgMS42MTI2MSwxLjEzNTAyMSA0LjA0NjUsMi43NDQ1MzggOS41MjUyMSw0LjY2MzExNiAxNS40NTgzNCw1LjcxNTI4IDYuMzYwNzcsMS4xMTg1NjYgMTMuMzI1NjIsMS4xNTk2MTYgMjAuMzM1OTYsMC40NzY3NTMgNy40Mzc0NCwtMC43Mzc2MTUgMTQuODcyMTYsLTIuMzQxMDY0IDIyLjA0NTkxLC00LjYxNzU2OSAtNi4yNDc2OSwzLjYzMDY4NSAtMTMuMTY3OTUsNi43NTk2NSAtMjAuNzI1Myw5LjA5MTI4NiAtMC45NjUyOSwwLjI5Nzg5NSAtMS45NDI0LDAuNTgxNzQgLTIuOTI5NDcsMC44NTIzNDEgMy4wNjExNyw0LjA3MzAzNiA3Ljc5MzYzLDcuNTk1NTE0IDEzLjQ2MzM5LDkuNzQ4MTE5IDUuNjkzMDgsMi4xODgxMzMgMTIuNDUxMjYsMy4xMjM5OTggMTkuMDk0NDUsMi42MTE1NTIgMy41NzY4NywtMC4yODE4MjYgNy4xNTE3MSwtMC45ODUzNDggMTAuNTA0NDQ2LC0yLjEwMzk1IC0zLjUwODg3NiwwLjg4ODc5MiAtNy4xNDQ2MjYsMS4zMjM2NSAtMTAuNjc1NzI2LDEuMzM3NzA1IC02LjU2MTY0LDAuMDE0MzYgLTEyLjg5MzMsLTEuNDI1MDUgLTE3LjgyMzQ0LC0zLjg5Njg4MSAtMC43NDM0NCwtMC4zNjc5MDcgLTEuNDU5NDMsLTAuNzYyNTcyIC0yLjE0NjU3LC0xLjE4MDkzOSAwLjcxODg0LDAuMzcxOTUgMS40NjExNSwwLjcxODE5MSAyLjIyNDcyLDEuMDM1NjUzIDUuMDYzMzUsMi4xNDI2MDYgMTEuMjgzNzIsMy4xODYxMTQgMTcuNDgzMjMsMi44NzA5MTMgNi4xMDMyLC0wLjMyNjA0OCAxMi4zMzAwNTYsLTEuOTY0NTY3IDE3LjMxMTAxNiwtNC45NDUwODcgNS4xNDc2LC0yLjk5NjMwOCA5LjA0NTA4LC03LjYzNzUwMSAxMC45ODUwNSwtMTIuODMxNDAxIC00LjM3MzE2LDAuNjk2OTUxIC04Ljg1OTkzLDEuMDk3NTYgLTEzLjQ0OTgzLDEuMDgyNjQ2IC04LjA3MTYxNiwtMC4wMzAyNiAtMTYuMzI4NTE2LC0xLjQyNTUzNyAtMjQuMTE0Nzg2LC0zLjk0NzgyIC03Ljg5MTYsLTIuNTU5MTc4IC0xNS4yNTEyNSwtNi4wNjU3ODkgLTIyLjEzNDM1LC05LjczODA3NSAtNC44NzMwNSwtMi41ODQwMTggLTkuNTk1MDMsLTUuMjU1NTUgLTE0LjI0MDIzLC03Ljg1OTQwOCA0Ljc0MDAxLDIuNTI5NDQyIDkuNTU3MDQsNS4xMjY3MzIgMTQuNTE1MzksNy42Mjk0NjEgNy4wMDQyMiwzLjU1NjMzOCAxNC40NTg2MSw2LjkzMTE2NyAyMi4zNTg1MSw5LjMxOTQzOSA1LjY5MjI4LDEuNzE5ODg5IDExLjU5NTE1LDIuODI5OTc1IDE3LjQzNzg0NiwzLjI0NzIyMSAtNS42MDIyMjYsLTEuMTE1OTQ3IC0xMC45OTM0NTYsLTIuODcwNzc1IC0xNS45OTg4NDYsLTUuMTE2MjAyIC02Ljk3NDU2LC0zLjEyODk0MiAtMTMuMjQzOTUsLTcuMTAzNzUyIC0xOS4yMTQ3MSwtMTEuMjc1OTUgLTMuODU3NzcsLTIuNjk1MzggLTcuNjA4MDgsLTUuNDc3Njc4IC0xMS4zNTM4MSwtOC4yNjE1NDQgMy44NjUyMSwyLjY5MDA5NCA3LjczNDU5LDUuMzc4MjQgMTEuNzAwNTcsNy45NzE2OSA2LjEzODg1LDQuMDEzMTg4IDEyLjU0MTU4LDcuODA3NjUxIDE5LjUzMiwxMC43MDMwNTggMy42MjMxNiwxLjUwMTgyMiA3LjQxOTI2LDIuNzQxODUxIDExLjMxNDAzLDMuNjY4MzcgLTMuNzA5MDUsLTEuMzMxMzg2IC03LjIxMDU1LC0yLjk0NzgyNyAtMTAuNDU5OTksLTQuNzc3NTYxIC02LjI4OTc0LC0zLjUzMTczNSAtMTEuNzU2MjQsLTcuODM5MDg4IC0xNy4wNjExMywtMTIuMzY5MzU3IC01Ljg0NzU0LC01LjAxMzY2MyAtMTEuNDI2MSwtMTAuMzEyNzI1IC0xNy40MTM1MSwtMTUuNTkzNjIgeiIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzEzOTciCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1LjI5MTY2NjksLTEwLjU4MzMzNCkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDEzNTMiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMGFhMDA7c3Ryb2tlOiMxZjI0MWM7c3Ryb2tlLXdpZHRoOjAuMjA5Nzc4cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0ibSAxNzAuNDE2MzcsMzEuOTY1NTg4IGMgLTYuMjQzOTcsNS4wNzQxNDEgLTEyLjA5NzE2LDEwLjE3OTg4IC0xOC4xNjg4MSwxNC45NjMzMzEgLTUuNTA5MjcsNC4zMTg5NDkgLTExLjExOTg2LDguMzgxMjU2IC0xNy4zODc3NiwxMS41OTQ1MDIgLTMuNjk5MjQsMS45MDQ5NiAtNy42NzY3NiwzLjUyMzE3NyAtMTEuODUxNzMsNC43NTYzOTUgNC4wNjU5OSwtMS40OTYwNzcgNy44NTIyMywtMy4zNTc3MzcgMTEuMzAyOCwtNS40Njk1NDkgNS44NjI1NywtMy41NjM3MjUgMTAuOTQwOCwtNy45MDkxNCAxNS45Nzk2NiwtMTIuNTE1MzYxIDAuNzk0OTUsLTAuNzMxODQyIDEuNTg1NDYsLTEuNDcwNTcyIDIuMzczOTksLTIuMjE1MTU2IC0wLjgzNTQ0LDAuNzA2NDI5IC0xLjY3MjQ5LDEuNDA2NTkxIC0yLjUxMjk4LDIuMDk5Mjg2IC01LjMyNzA4LDQuMzU4MTIzIC0xMC42NTg4OCw4LjQyODUwMyAtMTYuNjA0ODYsMTEuNjM4OTgzIC01Ljc0OTk3LDMuMTI4MjI0IC0xMi4yNTA3OSw1LjUzODkxOCAtMTkuMTc1NCw2Ljc3MTAyMyAtOC40MTE5LDEuNTQ2NzIgLTE3LjY0MTIzMSwxLjQxNzc0IC0yNi44MTk2MzgsMC4zNzEyODUgNC41MjE2ODQsMS4zNTgxNjMgOS4yMDI1NTMsMi40OTk2OTMgMTQuMDIyMTQ4LDMuMjgxNjU5IDAuMDg4MSw1LjUyMDEyMSAyLjM1OTYsMTEuMzMxODIgNy4yMDM0MSwxNi4xNDMxOTMgNC42NzM3Nyw0LjYzOTMxNiAxMS41NDAyNyw4LjI3ODY0OCAxOS40Mzk4MSwxMC4yMjcwMjQgNy45ODA1OSwxLjk3ODYzIDE2Ljk4MDE1LDIuMjgwNjggMjUuNzkyOTIsMC41MDY1MjYgNi4wNDUwNSwtMS4yNDM0NzYgMTEuODM5NjcsLTMuNDU2MzM5IDE2Ljk2NjEzLC02LjUyMjc4MSAtNS4yMjI3MiwyLjk5MzE1MSAtMTEuMDc2NTEsNS4xMDQzMTIgLTE3LjEyMTAzLDYuMjM0MzYzIC04LjgxNDU0LDEuNjEwNjAyIC0xNy43MDcwMywxLjEyNzg4OSAtMjUuNDY4NjIsLTAuOTc2NDYzIC01LjEwODc4LC0xLjM4MDAyNiAtOS43MTc2LC0zLjQ4MjgxNiAtMTMuNDkxOTQsLTYuMDgyMjYxIDQuMjQyNTQsMi4wMTQ3NzcgOS4wMTc4NSwzLjM4ODQxOSAxMy45NDU4Nyw0LjA1MTg1IDAsMCA0LjhlLTQsMCA0LjhlLTQsMCA3LjQ5NTMsMS4wMDkxOTcgMTUuMzcwNzUsMC40MDQxMTkgMjIuNDM4NTMsLTEuNzk2ODc2IDQuNDA3NDQsLTEuMzcyOTc0IDguNDYwNTgsLTMuMzg3NTYxIDExLjk0MTExLC01Ljg3ODg2MSAtMy41OTc3MSwyLjM5NTg4MiAtNy43MjM4Miw0LjI4MzIwNCAtMTIuMTM2MjUsNS41MTUxMDkgLTcuMDc5MDEsMS45NzgxMSAtMTQuODE1NjMsMi4zMzUyOTMgLTIyLjAxNzgzLDEuMTUxNTIyIC0zLjM1NTQ0LC0wLjU1Mjk3NCAtNi42MDQ2LC0xLjQ0NTg5NSAtOS42MTQ4NCwtMi42NDI3NjEgMy4yMzA3MywwLjgzNDk4NCA2LjU3MjI1LDEuMzE4ODI4IDkuODc4NzcsMS40NjE4MjQgNy4xMDIzLDAuMzAxMjQ0IDE0LjEyMjU5LC0wLjk1Nzc1NyAxOS44ODUzMSwtMy40NTU2NDQgNS43NTE5OSwtMi40NzI5MjMgMTAuMzIxODksLTYuMjg2NTU0IDEzLjA5OTc5LC0xMC41MjM2OTIgNi4yNzk4MSwxLjcxNzAyMSAxMi45OTIyNiwyLjg1MjgxNSAyMC4wNTMzMSwzLjAyNzY3OCA3Ljc2MDk1LDAuMTg5OTkzIDE1LjkwOTU5LC0wLjkyMjY4MyAyMy42MDkzOCwtMy44MjgzNjMgNS4yNDY1NiwtMi4wNDI1NjQgMTAuMDIzMzksLTQuODI5OTUgMTQuMTI3OTIsLTguMTUyNDkgLTQuMjExNDQsMy4yNjM3MDUgLTkuMDcwNiw1Ljk2NjQ5NyAtMTQuMzUwMiw3LjkwMjQ1NSAtNy43NDYxLDIuNzU0MTA3IC0xNS44NTQyMywzLjY4NDg4NiAtMjMuNTAzMTYsMy4zMzk3NzQgLTUuNjI1ODcsLTAuMjU1NDQgLTEwLjk5NTUyLC0xLjEzMjkyIC0xNi4wNzk4LC0yLjQyNTM3MSA1LjIxMzY3LDAuNTUzODA3IDEwLjUwMjgzLDAuNjcyMzM1IDE1LjczMjEsMC4yMDc3MDQgNy4wODY3NSwtMC42Mjk2NDMgMTQuMDU3OTIsLTIuNDAxNDc4IDE5Ljk4Nzc5LC01LjQ2OTE5MSAzLjY5ODAyLC0xLjkxNDM3NyA2LjkzMDgyLC00LjMxNTYzNyA5LjY1Mjc1LC03LjAzMDM4NSAtMi44NTM0MSwyLjYzNzk3MSAtNi4xODc1NSw0LjkzMzQ1NSAtOS45MzE2Niw2LjcxNjQ5NSAtNi4wMDEzMiwyLjg2MjMzNiAtMTIuOTIzODgsNC4zODUwODggLTE5Ljg2Mjg0LDQuODAxMjM5IC0zLjc1MTgxLDAuMjI0ODk5IC03LjUxMzgzLDAuMTQwMTA4IC0xMS4yNDE1LC0wLjE5MTU2MiAzLjc2OTk2LC0wLjExMzkxOCA3LjQ3Mzc0LC0wLjQ3ODk0MiAxMS4wMzI3OSwtMS4xMzg5NjYgNi41NjcwNywtMS4yMjE1MTUgMTIuNjUxOTYsLTMuNDYxNTIgMTcuMjY0MjIsLTYuNjI5Njg0IDUuMDEzNDIsLTMuMzYzODQzIDguNDc2OTksLTcuOTAzNjEzIDEwLjU1OTY2LC0xMi42NTcwNTkgLTIuNDExNjEsNC42MzI0MSAtNi4xMzYyLDguOTMzMDQgLTExLjE3NTUxLDExLjk2MzYzNCAtNC42MzA3OCwyLjg3MTMwMSAtMTAuNTg1MzQsNC43NzQwOTQgLTE2Ljg5OTY4LDUuNzE5MjI3IC0zLjkxNjYsMC41ODMzNDUgLTcuOTg5NjUsMC43ODg5MjMgLTEyLjExNzUzLDAuNjkwOTEzIDQuMTYzODYsLTAuMTg2NTU3IDguMjAxOTgsLTAuNjgxMjU2IDExLjk4NDE2LC0xLjU0MjE3OCA2LjA4NjY1LC0xLjM5NTMxMiAxMS41NTExNCwtMy42OTQyODYgMTUuMzgxNTksLTYuNzI2NTQgMC41Mjc3OCwtMC4zOTk0NjEgMS4wMzE3MiwtMC44MTU2MzIgMS41MTI5NCwtMS4yNDY5NDQgLTAuNTE3OTIsMC4zOTYwNjUgLTEuMDU1MzEsMC43NzQ5ODEgLTEuNjEyNjEsMS4xMzUwMjEgLTQuMDQ2NSwyLjc0NDUzOCAtOS41MjUyMSw0LjY2MzExNiAtMTUuNDU4MzQsNS43MTUyOCAtNi4zNjA3NywxLjExODU2NiAtMTMuMzI1NjIsMS4xNTk2MTYgLTIwLjMzNTk2LDAuNDc2NzUzIC03LjQzNzQ0LC0wLjczNzYxNSAtMTQuODcyMTYsLTIuMzQxMDY0IC0yMi4wNDU5MSwtNC42MTc1NjkgNi4yNDc2OSwzLjYzMDY4NSAxMy4xNjc5NSw2Ljc1OTY1IDIwLjcyNTMsOS4wOTEyODYgMC45NjUyOSwwLjI5Nzg5NSAxLjk0MjQsMC41ODE3NCAyLjkyOTQ3LDAuODUyMzQxIC0zLjA2MTE3LDQuMDczMDM2IC03Ljc5MzYzLDcuNTk1NTE0IC0xMy40NjMzOSw5Ljc0ODExOSAtNS42OTMwOCwyLjE4ODEzMyAtMTIuNDUxMjYsMy4xMjM5OTggLTE5LjA5NDQ1LDIuNjExNTUyIC0zLjU3Njg3LC0wLjI4MTgyNiAtNy4xNTE3MSwtMC45ODUzNDggLTEwLjUwNDQ1LC0yLjEwMzk1IDMuNTA4ODgsMC44ODg3OTIgNy4xNDQ2MywxLjMyMzY1IDEwLjY3NTczLDEuMzM3NzA1IDYuNTYxNjQsMC4wMTQzNiAxMi44OTMzLC0xLjQyNTA1IDE3LjgyMzQ0LC0zLjg5Njg4MSAwLjc0MzQ0LC0wLjM2NzkwNyAxLjQ1OTQzLC0wLjc2MjU3MiAyLjE0NjU3LC0xLjE4MDkzOSAtMC43MTg4NCwwLjM3MTk1IC0xLjQ2MTE1LDAuNzE4MTkxIC0yLjIyNDcyLDEuMDM1NjUzIC01LjA2MzM1LDIuMTQyNjA2IC0xMS4yODM3MiwzLjE4NjExNCAtMTcuNDgzMjMsMi44NzA5MTMgLTYuMTAzMiwtMC4zMjYwNDggLTEyLjMzMDA2LC0xLjk2NDU2NyAtMTcuMzExMDIsLTQuOTQ1MDg3IC01LjE0NzYsLTIuOTk2MzA4IC05LjA0NTA4LC03LjYzNzUwMSAtMTAuOTg1MDUsLTEyLjgzMTQwMSA0LjM3MzE2LDAuNjk2OTUxIDguODU5OTMsMS4wOTc1NiAxMy40NDk4MywxLjA4MjY0NiA4LjA3MTYyLC0wLjAzMDI2IDE2LjMyODUyLC0xLjQyNTUzNyAyNC4xMTQ3OSwtMy45NDc4MiA3Ljg5MTYsLTIuNTU5MTc4IDE1LjI1MTI1LC02LjA2NTc4OSAyMi4xMzQzNSwtOS43MzgwNzUgNC44NzMwNSwtMi41ODQwMTggOS41OTUwMywtNS4yNTU1NSAxNC4yNDAyMywtNy44NTk0MDggLTQuNzQwMDEsMi41Mjk0NDIgLTkuNTU3MDQsNS4xMjY3MzIgLTE0LjUxNTM5LDcuNjI5NDYxIC03LjAwNDIyLDMuNTU2MzM4IC0xNC40NTg2MSw2LjkzMTE2NyAtMjIuMzU4NTEsOS4zMTk0MzkgLTUuNjkyMjgsMS43MTk4ODkgLTExLjU5NTE1LDIuODI5OTc1IC0xNy40Mzc4NSwzLjI0NzIyMSA1LjYwMjIzLC0xLjExNTk0NyAxMC45OTM0NiwtMi44NzA3NzUgMTUuOTk4ODUsLTUuMTE2MjAyIDYuOTc0NTYsLTMuMTI4OTQyIDEzLjI0Mzk1LC03LjEwMzc1MiAxOS4yMTQ3MSwtMTEuMjc1OTUgMy44NTc3NywtMi42OTUzOCA3LjYwODA4LC01LjQ3NzY3OCAxMS4zNTM4MSwtOC4yNjE1NDQgLTMuODY1MjEsMi42OTAwOTQgLTcuNzM0NTksNS4zNzgyNCAtMTEuNzAwNTcsNy45NzE2OSAtNi4xMzg4NSw0LjAxMzE4OCAtMTIuNTQxNTgsNy44MDc2NTEgLTE5LjUzMiwxMC43MDMwNTggLTMuNjIzMTYsMS41MDE4MjIgLTcuNDE5MjYsMi43NDE4NTEgLTExLjMxNDAzLDMuNjY4MzcgMy43MDkwNSwtMS4zMzEzODYgNy4yMTA1NSwtMi45NDc4MjcgMTAuNDU5OTksLTQuNzc3NTYxIDYuMjg5NzQsLTMuNTMxNzM1IDExLjc1NjI0LC03LjgzOTA4OCAxNy4wNjExMywtMTIuMzY5MzU3IDUuODQ3NTQsLTUuMDEzNjYzIDExLjQyNjEsLTEwLjMxMjcyNSAxNy40MTM1MSwtMTUuNTkzNjIgeiIgLz4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGgxMzkzIgogICAgICAgICBzdHlsZT0iZmlsbDojMDBhYTAwO3N0cm9rZTojMWYyNDFjO3N0cm9rZS13aWR0aDowLjIwOTc3OHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGQ9Im0gNTEuMDg3NTc0LDMxLjk2NTU4OCBjIDYuMjQzOTcsNS4wNzQxNDEgMTIuMDk3MTYsMTAuMTc5ODggMTguMTY4ODEsMTQuOTYzMzMxIDUuNTA5MjcsNC4zMTg5NDkgMTEuMTE5ODYsOC4zODEyNTYgMTcuMzg3NzYsMTEuNTk0NTAyIDMuNjk5MjQsMS45MDQ5NiA3LjY3Njc2LDMuNTIzMTc3IDExLjg1MTczLDQuNzU2Mzk1IC00LjA2NTk5LC0xLjQ5NjA3NyAtNy44NTIyMywtMy4zNTc3MzcgLTExLjMwMjgsLTUuNDY5NTQ5IC01Ljg2MjU3LC0zLjU2MzcyNSAtMTAuOTQwOCwtNy45MDkxNCAtMTUuOTc5NjYsLTEyLjUxNTM2MSAtMC43OTQ5NSwtMC43MzE4NDIgLTEuNTg1NDYsLTEuNDcwNTcyIC0yLjM3Mzk5LC0yLjIxNTE1NiAwLjgzNTQ0LDAuNzA2NDI5IDEuNjcyNDksMS40MDY1OTEgMi41MTI5OCwyLjA5OTI4NiA1LjMyNzA4LDQuMzU4MTIzIDEwLjY1ODg4LDguNDI4NTAzIDE2LjYwNDg2LDExLjYzODk4MyA1Ljc0OTk3LDMuMTI4MjI0IDEyLjI1MDc4Niw1LjUzODkxOCAxOS4xNzUzOTYsNi43NzEwMjMgOC40MTE5LDEuNTQ2NzIgMTcuNjQxMjMsMS40MTc3NCAyNi44MTk2NCwwLjM3MTI4NSAtNC41MjE2OCwxLjM1ODE2MyAtOS4yMDI1NSwyLjQ5OTY5MyAtMTQuMDIyMTUsMy4yODE2NTkgLTAuMDg4MSw1LjUyMDEyMSAtMi4zNTk2LDExLjMzMTgyIC03LjIwMzQxLDE2LjE0MzE5MyAtNC42NzM3Nyw0LjYzOTMxNiAtMTEuNTQwMjcsOC4yNzg2NDggLTE5LjQzOTgwNiwxMC4yMjcwMjQgLTcuOTgwNTksMS45Nzg2MyAtMTYuOTgwMTUsMi4yODA2OCAtMjUuNzkyOTIsMC41MDY1MjYgLTYuMDQ1MDUsLTEuMjQzNDc2IC0xMS44Mzk2NywtMy40NTYzMzkgLTE2Ljk2NjEzLC02LjUyMjc4MSA1LjIyMjcyLDIuOTkzMTUxIDExLjA3NjUxLDUuMTA0MzEyIDE3LjEyMTAzLDYuMjM0MzYzIDguODE0NTQsMS42MTA2MDIgMTcuNzA3MDMsMS4xMjc4ODkgMjUuNDY4NjIsLTAuOTc2NDYzIDUuMTA4NzgsLTEuMzgwMDI2IDkuNzE3NTk2LC0zLjQ4MjgxNiAxMy40OTE5MzYsLTYuMDgyMjYxIC00LjI0MjU0LDIuMDE0Nzc3IC05LjAxNzg0NiwzLjM4ODQxOSAtMTMuOTQ1ODY2LDQuMDUxODUgMCwwIC00LjhlLTQsMCAtNC44ZS00LDAgLTcuNDk1MywxLjAwOTE5NyAtMTUuMzcwNzUsMC40MDQxMTkgLTIyLjQzODUzLC0xLjc5Njg3NiAtNC40MDc0NCwtMS4zNzI5NzQgLTguNDYwNTgsLTMuMzg3NTYxIC0xMS45NDExMSwtNS44Nzg4NjEgMy41OTc3MSwyLjM5NTg4MiA3LjcyMzgyLDQuMjgzMjA0IDEyLjEzNjI1LDUuNTE1MTA5IDcuMDc5MDEsMS45NzgxMSAxNC44MTU2MywyLjMzNTI5MyAyMi4wMTc4MywxLjE1MTUyMiAzLjM1NTQ0LC0wLjU1Mjk3NCA2LjYwNDYsLTEuNDQ1ODk1IDkuNjE0ODM2LC0yLjY0Mjc2MSAtMy4yMzA3MjYsMC44MzQ5ODQgLTYuNTcyMjQ2LDEuMzE4ODI4IC05Ljg3ODc2NiwxLjQ2MTgyNCAtNy4xMDIzLDAuMzAxMjQ0IC0xNC4xMjI1OSwtMC45NTc3NTcgLTE5Ljg4NTMxLC0zLjQ1NTY0NCAtNS43NTE5OSwtMi40NzI5MjMgLTEwLjMyMTg5LC02LjI4NjU1NCAtMTMuMDk5NzksLTEwLjUyMzY5MiAtNi4yNzk4MSwxLjcxNzAyMSAtMTIuOTkyMjYsMi44NTI4MTUgLTIwLjA1MzMxLDMuMDI3Njc4IC03Ljc2MDk1LDAuMTg5OTkzIC0xNS45MDk1OSwtMC45MjI2ODMgLTIzLjYwOTM4LC0zLjgyODM2MyAtNS4yNDY1NTgsLTIuMDQyNTY0IC0xMC4wMjMzODgzLC00LjgyOTk1IC0xNC4xMjc5MTgzLC04LjE1MjQ5IDQuMjExNDQsMy4yNjM3MDUgOS4wNzA2MDAzLDUuOTY2NDk3IDE0LjM1MDE5ODMsNy45MDI0NTUgNy43NDYxLDIuNzU0MTA3IDE1Ljg1NDIzLDMuNjg0ODg2IDIzLjUwMzE2LDMuMzM5Nzc0IDUuNjI1ODcsLTAuMjU1NDQgMTAuOTk1NTIsLTEuMTMyOTIgMTYuMDc5OCwtMi40MjUzNzEgLTUuMjEzNjcsMC41NTM4MDcgLTEwLjUwMjgzLDAuNjcyMzM1IC0xNS43MzIxLDAuMjA3NzA0IC03LjA4Njc1LC0wLjYyOTY0MyAtMTQuMDU3OTIsLTIuNDAxNDc4IC0xOS45ODc3OSwtNS40NjkxOTEgLTMuNjk4MDIsLTEuOTE0Mzc3IC02LjkzMDgxOCwtNC4zMTU2MzcgLTkuNjUyNzQ4MywtNy4wMzAzODUgMi44NTM0MTAzLDIuNjM3OTcxIDYuMTg3NTQ4Myw0LjkzMzQ1NSA5LjkzMTY1ODMsNi43MTY0OTUgNi4wMDEzMiwyLjg2MjMzNiAxMi45MjM4OCw0LjM4NTA4OCAxOS44NjI4NCw0LjgwMTIzOSAzLjc1MTgxLDAuMjI0ODk5IDcuNTEzODMsMC4xNDAxMDggMTEuMjQxNSwtMC4xOTE1NjIgLTMuNzY5OTYsLTAuMTEzOTE4IC03LjQ3Mzc0LC0wLjQ3ODk0MiAtMTEuMDMyNzksLTEuMTM4OTY2IC02LjU2NzA3LC0xLjIyMTUxNSAtMTIuNjUxOTYsLTMuNDYxNTIgLTE3LjI2NDIyLC02LjYyOTY4NCAtNS4wMTM0MiwtMy4zNjM4NDMgLTguNDc2OTksLTcuOTAzNjEzIC0xMC41NTk2NTgsLTEyLjY1NzA1OSAyLjQxMTYwOCw0LjYzMjQxIDYuMTM2MTk4LDguOTMzMDQgMTEuMTc1NTA4LDExLjk2MzYzNCA0LjYzMDc4LDIuODcxMzAxIDEwLjU4NTM0LDQuNzc0MDk0IDE2Ljg5OTY4LDUuNzE5MjI3IDMuOTE2NiwwLjU4MzM0NSA3Ljk4OTY1LDAuNzg4OTIzIDEyLjExNzUzLDAuNjkwOTEzIC00LjE2Mzg2LC0wLjE4NjU1NyAtOC4yMDE5OCwtMC42ODEyNTYgLTExLjk4NDE2LC0xLjU0MjE3OCAtNi4wODY2NSwtMS4zOTUzMTIgLTExLjU1MTE0LC0zLjY5NDI4NiAtMTUuMzgxNTksLTYuNzI2NTQgLTAuNTI3NzgsLTAuMzk5NDYxIC0xLjAzMTcyLC0wLjgxNTYzMiAtMS41MTI5NCwtMS4yNDY5NDQgMC41MTc5MiwwLjM5NjA2NSAxLjA1NTMxLDAuNzc0OTgxIDEuNjEyNjEsMS4xMzUwMjEgNC4wNDY1LDIuNzQ0NTM4IDkuNTI1MjEsNC42NjMxMTYgMTUuNDU4MzQsNS43MTUyOCA2LjM2MDc3LDEuMTE4NTY2IDEzLjMyNTYyLDEuMTU5NjE2IDIwLjMzNTk2LDAuNDc2NzUzIDcuNDM3NDQsLTAuNzM3NjE1IDE0Ljg3MjE2LC0yLjM0MTA2NCAyMi4wNDU5MSwtNC42MTc1NjkgLTYuMjQ3NjksMy42MzA2ODUgLTEzLjE2Nzk1LDYuNzU5NjUgLTIwLjcyNTMsOS4wOTEyODYgLTAuOTY1MjksMC4yOTc4OTUgLTEuOTQyNCwwLjU4MTc0IC0yLjkyOTQ3LDAuODUyMzQxIDMuMDYxMTcsNC4wNzMwMzYgNy43OTM2Myw3LjU5NTUxNCAxMy40NjMzOSw5Ljc0ODExOSA1LjY5MzA4LDIuMTg4MTMzIDEyLjQ1MTI2LDMuMTIzOTk4IDE5LjA5NDQ1LDIuNjExNTUyIDMuNTc2ODcsLTAuMjgxODI2IDcuMTUxNzEsLTAuOTg1MzQ4IDEwLjUwNDQ0NiwtMi4xMDM5NSAtMy41MDg4NzYsMC44ODg3OTIgLTcuMTQ0NjI2LDEuMzIzNjUgLTEwLjY3NTcyNiwxLjMzNzcwNSAtNi41NjE2NCwwLjAxNDM2IC0xMi44OTMzLC0xLjQyNTA1IC0xNy44MjM0NCwtMy44OTY4ODEgLTAuNzQzNDQsLTAuMzY3OTA3IC0xLjQ1OTQzLC0wLjc2MjU3MiAtMi4xNDY1NywtMS4xODA5MzkgMC43MTg4NCwwLjM3MTk1IDEuNDYxMTUsMC43MTgxOTEgMi4yMjQ3MiwxLjAzNTY1MyA1LjA2MzM1LDIuMTQyNjA2IDExLjI4MzcyLDMuMTg2MTE0IDE3LjQ4MzIzLDIuODcwOTEzIDYuMTAzMiwtMC4zMjYwNDggMTIuMzMwMDU2LC0xLjk2NDU2NyAxNy4zMTEwMTYsLTQuOTQ1MDg3IDUuMTQ3NiwtMi45OTYzMDggOS4wNDUwOCwtNy42Mzc1MDEgMTAuOTg1MDUsLTEyLjgzMTQwMSAtNC4zNzMxNiwwLjY5Njk1MSAtOC44NTk5MywxLjA5NzU2IC0xMy40NDk4MywxLjA4MjY0NiAtOC4wNzE2MTYsLTAuMDMwMjYgLTE2LjMyODUxNiwtMS40MjU1MzcgLTI0LjExNDc4NiwtMy45NDc4MiAtNy44OTE2LC0yLjU1OTE3OCAtMTUuMjUxMjUsLTYuMDY1Nzg5IC0yMi4xMzQzNSwtOS43MzgwNzUgLTQuODczMDUsLTIuNTg0MDE4IC05LjU5NTAzLC01LjI1NTU1IC0xNC4yNDAyMywtNy44NTk0MDggNC43NDAwMSwyLjUyOTQ0MiA5LjU1NzA0LDUuMTI2NzMyIDE0LjUxNTM5LDcuNjI5NDYxIDcuMDA0MjIsMy41NTYzMzggMTQuNDU4NjEsNi45MzExNjcgMjIuMzU4NTEsOS4zMTk0MzkgNS42OTIyOCwxLjcxOTg4OSAxMS41OTUxNSwyLjgyOTk3NSAxNy40Mzc4NDYsMy4yNDcyMjEgLTUuNjAyMjI2LC0xLjExNTk0NyAtMTAuOTkzNDU2LC0yLjg3MDc3NSAtMTUuOTk4ODQ2LC01LjExNjIwMiAtNi45NzQ1NiwtMy4xMjg5NDIgLTEzLjI0Mzk1LC03LjEwMzc1MiAtMTkuMjE0NzEsLTExLjI3NTk1IC0zLjg1Nzc3LC0yLjY5NTM4IC03LjYwODA4LC01LjQ3NzY3OCAtMTEuMzUzODEsLTguMjYxNTQ0IDMuODY1MjEsMi42OTAwOTQgNy43MzQ1OSw1LjM3ODI0IDExLjcwMDU3LDcuOTcxNjkgNi4xMzg4NSw0LjAxMzE4OCAxMi41NDE1OCw3LjgwNzY1MSAxOS41MzIsMTAuNzAzMDU4IDMuNjIzMTYsMS41MDE4MjIgNy40MTkyNiwyLjc0MTg1MSAxMS4zMTQwMywzLjY2ODM3IC0zLjcwOTA1LC0xLjMzMTM4NiAtNy4yMTA1NSwtMi45NDc4MjcgLTEwLjQ1OTk5LC00Ljc3NzU2MSAtNi4yODk3NCwtMy41MzE3MzUgLTExLjc1NjI0LC03LjgzOTA4OCAtMTcuMDYxMTMsLTEyLjM2OTM1NyAtNS44NDc1NCwtNS4wMTM2NjMgLTExLjQyNjEsLTEwLjMxMjcyNSAtMTcuNDEzNTEsLTE1LjU5MzYyIHoiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K");
  --totalpagenum: "${totalpagenum}";
  --onedot: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxjaXJjbGUgY3g9Ijg1IiBjeT0iMTUiIHI9IjEwIi8+DQo8L3N2Zz4NCg==");
  --twodot: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9J2N1cnJlbnRDb2xvcicgdmlld0JveD0iMCAwIDEwMCAxMDAiPg0KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSIyMCIvPiANCjwvc3ZnPg0K");
  --buttoncopy: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxyZWN0IHg9IjE4IiB5PSIzOCIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjEiLz4NCjxyZWN0IHg9IjM4IiB5PSIxOCIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjEiLz4NCjwvc3ZnPg0K");
  --buttonpaste: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxyZWN0IHg9IjE4IiB5PSIzOCIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjEiLz4NCjxyZWN0IHg9IjM4IiB5PSIxOCIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+DQo8L3N2Zz4NCg==");
  --onedotwhite: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxjaXJjbGUgZmlsbD0nd2hpdGUnIGN4PSI4NSIgY3k9IjE1IiByPSIxMCIvPg0KPC9zdmc+DQo=");
  counter-reset: pagenum;      
}
:root {
${allsidesvgs.join('\n')}
}
table {
  font-size: 10pt;
  color: #124A47;
  line-height: 1.00;
  table-layout: fixed;
}
.ONE {
  width:  15px;
  height: 15px;
  width:  15px;
  height: 15px;
  margin-left:  1px;
  margin-right: 1px;
  margin-top:  1px;
  margin-bottom: 1px;
  border-radius: 3px;
  box-sizing: border-box;
  font-size: 8px;
  padding: 0;
}
.ONE.OP {
  background-color: black;
  color: white;
}
.ONE.CL {
  background-color: black;
}
.ONE.ST {
  background-color: black;
  color: white;
}
.ONE.SH {
  background-color: black;
  color: white;
}
.ONE.C0 {
  color: SlateGray;
}
.ONE.C1 {
  color: RoyalBlue;
}
.ONE.C2 {
  color: OliveDrab; 
}
.ONE.C3 {
  color: DarkOrchid;
}
.ONE.C4 {
  color: Turquoise;
}
.ONE.C5 {
  color: DarkOrange;
}
.ONE.C6 {
  color: DeepPink;
}
.ONE.AT {
  background-color: white;
}
.ONE.TE {
  height: 32px;
  width: 86px;
  max-height: 32px;
  flex: 1;
  align-self: flex-start;
}
.ONE:hover {
  outline: 1px solid black;
}
.ONE.OP.DOT {
  background-image: var(--onedotwhite);
}
.ONE.CL.DOT {
  background-image: var(--onedotwhite);
}
.ONE.ST.DOT {
  background-image: var(--onedotwhite);
}
.ONE.SH.DOT {
  background-image: var(--onedotwhite);
}
.TOOLMENU {
  background-color: transparent;
}
.DROPMENU {
  visibility: hidden;
  position: absolute;
  bottom: 100%;
  left: 0px;
  background-color: #f1f1f1;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
}
.DROPMENU.SHOW {
  visibility: visible;
}
.DROPDOWNCONTAINER:hover .BUTTON.VISIBLE + .DROPMENU {
  visibility: visible;
}
.BUTTON {
  background-color: transparent;
  color: white;
  font-size: 12px;
  padding: 0;
  user-select: none;
  touch-action: manipulation;
  min-width:  20px;
  min-height: 20px;
  max-width:  20px;
  max-height: 20px;
  margin-top: auto;
  margin-bottom: auto;
}
.BUTTON.CAKE {
}
.BUTTON.VISIBLE {
  background-color: black;
  color: white;
}
.EDITFORM {
  position: relative;
  margin-left: 0;
  margin-right: auto;
  margin-top: auto;
  margin-bottom: auto;
  align-left: center;
  display: inline-flex;
  flex-direction: row;
  align-items: center;
}
.PAGENUM {
  margin-left: auto;
  margin-right: 2px;
  margin-top: auto;
  margin-bottom: auto;
  font-size: 1.0em;
}
.PAGENUM::before {
  counter-increment: pagenum;
  content: counter(pagenum);
}
.PAGENUM::after {
  content: var(--totalpagenum);
}
.TOPCONTAINER {
  position: absolute;
  top: 0px;
  right: 0px;
  left: 88px;
  height: 40px;
  background-color: #DDEEFF;
}
.SIDECONTAINER {
  position: absolute;
  top: 40px;
  left: 0px;
  bottom: 40px;
  width: 88px;
  overflow: hidden;
  background-color: #DDEEFF;
}
.BOTTOMCONTAINER {
  position: absolute;
  bottom: 0px;
  left: 0px;
  right: 0px;
  height: 40px;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
  background-color: #B3DAFF;
}
.INSIDECONTAINER {
  position: absolute;
  top: 40px;
  left: 88px;
  bottom: 40px;
  right: 0px;
  padding: 0px 44px 0px 30px;
}
.BOARD {
  position: absolute;
  left: 118px;
  top: 40px;
}
.BOARD.CAKE {
  z-index: 1;
}
.BOARD.WHITE {
  background-color: white;
}
.FRONTMATTERTITLE {
  margin-left: 6.5mm;
  margin-right: 6.5mm;
  margin-top: 2.5cm;
  margin-bottom: 0;
  font-size: 1.8em;
  text-align: center;
  align-self: center;
}
.FRONTMATTERSUBTITLE {
  margin-left: 6.5mm;
  margin-right: 6.5mm;
  margin-top: 0.8cm;
  margin-bottom: 0;
  font-size: 1.1em;
  text-align: center;
  align-self: center;
}
.FRONTMATTERINSTITUTE {
  margin-left: 6.5mm;
  margin-right: 6.5mm;
  margin-top: 0.2cm;
  margin-bottom: 0;
  font-size: 1.1em;
  text-align: center;
  align-self: center;
}
.FRONTMATTERAUTHOR {
  margin-left: 6.5mm;
  margin-right: 6.5mm;
  margin-top: 0.2cm;
  margin-bottom: 0;
  font-size: 1.1em;
  text-align: center;
  align-self: center;
}
.FRONTMATTERDATE {
  margin-left: 6.5mm;
  margin-right: 6.5mm;
  margin-top: 0.2cm;
  margin-bottom: 0;
  font-size: 1.1em;
  text-align: center;
  align-self: center;
}
.FRONTMATTERTOC  {
  font-size: 0.8em;
  text-align: left;   
  margin-top: 0pt;   
  margin-bottom: 6pt;   
}
@media print {
  @page {
    size: 151mm 106mm;
    margin: 0 0 0 0;
  }  
  .SLIDE {
    color: #124A47;
    position: relative;
    page-break-inside: avoid;
    page-break-after: always;
    min-width:100vw;
    max-width:100vw;
    min-height:100vh;
    max-height:100vh;
    box-sizing:border-box;
    overflow: hidden;
  }
  .SLIDE.COVER {
    padding: 40px 34px 1px 34px;
  }
  body {
    margin:0;
    padding:0;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 10pt;
    line-height: 1.25;
  }
}
@media screen {
  .SLIDE {
    color: #124A47;
    background-color: #F4F4F4;
    position: relative;
    outline: 1px solid #124A47;
    margin: 1em;
    min-width:151mm;
    max-width:151mm;
    min-height:106mm;
    max-height:106mm;
    box-sizing:border-box;
    overflow: visible;
  }
  .SLIDE.COVER {
    padding: 40px 34px 1px 34px;
  }
  body {
    background-color: lightgray;
    box-sizing:border-box;
    padding:1px 0;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 10pt;
    line-height: 1.25;
  }
}
`;
    var body = `
${allsidemaps.join('\n')}
${title_html}
${main_html}
`;
    var members = this.parser.members;
    return {stylesheet,script,body,members};
  }
  to_main_html(toc,pages) {
    let top = this.presentation.to_top(this.parser.blocks);
    ///
    ///
    ///
    var d = [];
    var topframes = [];
    top.sections.forEach((sect,i,arr) => {
      let topframe = this.presentation.to_frame(sect.blocks);
      topframes.push(topframe);
      if(sect.sections.length){
        let subframes = [];
        topframe.subframes = subframes;
        sect.sections.forEach((subblocks) => {
          ///note that each subsection is just a 'blocks'
          let subframe = this.presentation.to_frame(subblocks);
          subframes.push(subframe);
        });
        let out = this.write_frame_folder(`${i+1}`,topframe,subframes,toc,pages);
        d.push(out);
        topframe.subframes.forEach((subframe,j) => {
          let id = `${i+1}x${j+1}`;
          let order = `${i+1}.${j+1}`;
          let icon = this.icon_folder;
          let out = this.write_one_frame(id,order,subframe,1,`${i+1}`,toc,pages,topframe);
          d.push(out);
        });
      }else{
        let id = `${i+1}`;
        let order = i+1;
        let icon = this.icon_folder;
        let out = this.write_one_frame(id,order,topframe,0,'',toc,pages,topframe);
        d.push(out);
      }
    });
    var text = d.join('\n');
    //
    //title and table of contents
    //
    var table_of_contents_frame = this.write_frame_toc(topframes,pages);
    //
    // put together
    //
    var d = [];
    //d.push(table_of_contents_frame); //for now do not add toc slide
    d.push(text);
    return d.join('\n');
  }
  write_frame_toc(topframes,pages){
    /// decide if we need to change fonts
    var all = [];
    var n = 0;
    var max_n = 16;
    topframes.forEach((topframe,j,arr) => {
      if(n==max_n){
        all.push(`</ul>`);
        all.push('</div>')
        all.push('</article>');
        all.push(''); 
        n=0;
      }
      let paragraph_css = ('FRONTMATTERTOC');
      let ul_css = ('PARA UL');
      let li_css = ('PACK LI');
      if(n==0){
        all.push(`<article row='0' class='SLIDE' style='background-image:var(--logosvg);background-repeat:no-repeat;background-position:top left;background-size:88px 40px;' >`);
        pages.push('');
        all.push(`<div class='SIDECONTAINER'> </div>`);
        all.push(`<div class='BOTTOMCONTAINER'> <div class='EDITFORM'> </div> <div class='PAGENUM'> / </div> </div>`);
        all.push(`<div class='${paragraph_css}'>`)
        all.push(`<ul class='${ul_css}' style='list-style:none;'>`);
      }
      let icon = `<span style='position:absolute;right:100%;top:50%;transform:translate(-1.12ex,-50%);'>${j+1}.</span>`;
      if(topframe.subframes && topframe.subframes.length){
        all.push(`<li class='${li_css}' style='position:relative'> ${icon} <a href='#frame-${j+1}'> ${this.uncode(topframe.style,topframe.title)} </a> </li>`);
      }else{
        all.push(`<li class='${li_css}' style='position:relative'> ${icon} <a href='#frame-${j+1}'> ${this.uncode(topframe.style,topframe.title)} </a> </li>`);
      }
      n++;
    });
    all.push(`</ul>`);
    all.push('</div>')
    all.push('</article>');
    all.push(''); 
    return all.join('\n')
  }
  write_frame_folder(id,frame,subframes,toc,pages){
    let all = [];
    //
    //NOTE: main contents
    //
    let frameid = `frame-${id}`;
    let boardid = `board-${id}`;
    let boardname = frame.boardname;
    let boardpng = boardname?boardname+'.png':'';
    let imgid = `img-${id}`;
    let tool_contents = this.to_tool_contents(boardid);
    all.push(`<article class='SLIDE' id='${frameid}' row='${frame.style.row}' style='background-image:var(--logosvg);background-repeat:no-repeat;background-position:top left;background-size:88px 40px;' >`);
    pages.push(1);
    all.push(`<div class='TOPCONTAINER'> 
              <h1 class='TITLE' style='${this.css("TITLE")}' > ${id} ${this.uncode(frame.style,frame.title)} </h1>
              <h2 class='TITLE2' style='${this.css("TITLE2")}' > &#160; </h2>
              </div>`);
    all.push(`<div class='SIDECONTAINER'><img width='88' height='360' style='content:var(--side${id})' usemap='#map${id}' /> </div>`);
    all.push(`<div class='BOTTOMCONTAINER'> <div class='EDITFORM'> ${tool_contents} </div> <div class='PAGENUM'> / </div> </div>`);
    all.push(`<canvas class='BOARD' id='${boardid}' data-boardpng='${boardpng}' data-frameid='${frameid}' width='${this.board_width}' height='${this.board_height}' style='background-size:114mm 80mm;' onmouseenter="board_onmouseenter()" onmoueleave="board_onmouseleave()" onmousedown="board_onmousedown()" onmousemove="board_onmousemove()" onmouseup="board_onmouseup()" ontouchstart="board_ontouchstart()" ontouchmove="board_ontouchmove()" ontouchend="board_ontouchend()" ontouchcancel="board_ontouchcancel()" ></canvas>`);
    all.push(`<img id='${imgid}' src="${boardpng}" style='display:none' onload='paint_canvas("${imgid}","${boardid}")' />`);
    all.push(`<div class='INSIDECONTAINER'>`);
    if(1){
      let order = id;
      toc.push({id,order,icon:'',style:frame.style,title:frame.title,posticon:''})
      // contents of this frame
      frame.contents.forEach((x) => {
        ///'x' is a block
        let html = this.translate_block(x);
        all.push('');
        all.push(html.trim());
      })
      // all subframes of this frame
      all.push(`<div class='ITEMIZE' >`)
      subframes.forEach((subframe,j,arr) => {
        if(j==0){
          all.push(`<ul class='PARA UL' style='list-style:none;padding-left:0em;'>`);
        }
        //let icon = `<span style='position:absolute;right:100%;top:50%;transform:translate(-1.12ex,-50%);'>${j+1}</span>`;
        let icon = this.icon_folder;
        all.push(`<li class='PACK LI' style='position:relative;font-style:oblique;'> ${icon} <a href='#frame-${id}x${j+1}'> ${this.uncode(subframe.style,subframe.title)} </a> </li>`);
        if(j+1==arr.length){
          all.push(`</ul>`);
        }
      });
      all.push(`</div>`);
    }
    all.push(`</div>`);
    //all.push(`<canvas class='BOARD HIDDEN CAKE' id='${boardid}' data-frameid='${frameid}' width='483' height='361' style='background-image:url("${boardpng}");background-repeat:no-repeat;' onmouseenter="board_onmouseenter()" onmoueleave="board_onmouseleave()" onmousedown="board_onmousedown()" onmousemove="board_onmousemove()" onmouseup="board_onmouseup()" ontouchstart="board_ontouchstart()" ontouchmove="board_ontouchmove()" ontouchend="board_ontouchend()" ontouchcancel="board_ontouchcancel()" ></canvas>`);
    all.push('</article>');
    all.push('');
    //
    //NOTE: end
    //
    return all.join('\n');
  }
  write_one_frame(id,order,frame,issub,parentid,toc,pages,topframe){
    let icon = this.icon_folder;
    let all = [];
    //
    //NOTE: main contents
    //
    let frameid = `frame-${id}`;
    let boardid = `board-${id}`;
    let boardname = frame.boardname;
    let boardpng = boardname?boardname+'.png':'';
    let imgid = `img-${id}`;
    let tool_contents = this.to_tool_contents(boardid);
    all.push(`<article class='SLIDE' id='${frameid}' row='${frame.style.row}' style='background-image:var(--logosvg);background-repeat:no-repeat;background-position:top left;background-size:88px 40px;' >`);
    pages.push(1);
    if(issub){
      all.push(`<div class='TOPCONTAINER'> 
      <h1 class='TITLE' style='${this.css("TITLE")}' > ${order} ${this.uncode(topframe.style,topframe.title)} </h1>
      <h2 class='TITLE2' style='${this.css("TITLE2")}' > ${icon} ${this.uncode(frame.style,frame.title)} </h2>
      </div>`);
      order = '';
    }else{
      order = order;
      icon = '';
      all.push(`<div class='TOPCONTAINER'> 
      <h1 class='TITLE' style='${this.css("TITLE")}' > ${order} ${this.uncode(topframe.style,topframe.title)} </h1>
      <h2 class='TITLE2' style='${this.css("TITLE2")}' > &#160; </h2>
      </div>`);
    }
    all.push(`<div class='SIDECONTAINER'><img width='88' height='360' style='content:var(--side${id})' usemap='#map${id}' /> </div>`);
    all.push(`<div class='BOTTOMCONTAINER'> <div class='EDITFORM'> ${tool_contents} </div> <div class='PAGENUM'> / </div> </div>`);
    all.push(`<canvas class='BOARD' id='${boardid}' data-boardpng='${boardpng}' data-frameid='${frameid}' width='${this.board_width}' height='${this.board_height}' style='background-size:114mm 80mm;' onmouseenter="board_onmouseenter()" onmoueleave="board_onmouseleave()" onmousedown="board_onmousedown()" onmousemove="board_onmousemove()" onmouseup="board_onmouseup()" ontouchstart="board_ontouchstart()" ontouchmove="board_ontouchmove()" ontouchend="board_ontouchend()" ontouchcancel="board_ontouchcancel()" ></canvas>`);
    all.push(`<img id='${imgid}' src="${boardpng}" style='display:none' onload='paint_canvas("${imgid}","${boardid}")' />`);
    all.push(`<div class='INSIDECONTAINER'>`);
    if(1){
      toc.push({id,order,icon,style:frame.style,title:frame.title,posticon:'',issub})
      frame.contents.forEach((x,i) => {
        ///'x' is a block
        let html = this.translate_block(x);
        all.push('');
        all.push(html.trim());
      }) 
      frame.solutions.forEach((o,i,arr) => {
        if(o.choice){
          let text = this.to_choice(o.style,o.body);
          all.push(`<div class='PARAGRAPH'> ${this.icon_solution} <i>${this.uncode(o.style,o.title)}</i> ${text} </div>`);
        }else{
          all.push(`<div class='PARAGRAPH'> ${this.icon_solution} <i>${this.uncode(o.style,o.title)}</i> </div>`);
        }
      });
    }
    all.push(`</div>`);
    all.push('</article>');
    all.push('');
    // 
    //NOTE: individual solution-slides
    //
    frame.solutions.forEach((o,i,arr) => {
      let frameid = `frame-${id}a${i}`;
      let boardid = `board-${id}a${i}`;
      let boardname = '';//empty imgs
      let boardpng = '';//empty png
      let tool_contents = this.to_tool_contents(boardid);
      all.push(`<article class='SLIDE' id='${frameid}' row='${frame.style.row}' style='background-image:var(--logosvg);background-repeat:no-repeat;background-position:top left;background-size:88px 40px;' >`);
      pages.push(1);
      all.push(`<div class='TOPCONTAINER' style='background-color:transparent;' > 
                <h1 class='TITLE' style='${this.css("TITLE")}' > &#160; </h1>
                <h2 class='TITLE2' style='${this.css("TITLE2")}' > &#160; </h2>
                </div>`);
      all.push(`<div class='SIDECONTAINER'>                                                                                    </div>`);
      all.push(`<div class='BOTTOMCONTAINER'> <div class='EDITFORM' > ${tool_contents} </div> <div class='PAGENUM'> / </div> </div>`);
      all.push(`<canvas class='BOARD' id='${boardid}' data-boardpng='${boardpng}' data-frameid='${frameid}' width='${this.board_width}' height='${this.board_height}' style='background-image:url("");background-repeat:no-repeat;background-size:114mm 80mm;' onmouseenter="board_onmouseenter()" onmoueleave="board_onmouseleave()" onmousedown="board_onmousedown()" onmousemove="board_onmousemove()" onmouseup="board_onmouseup()" ontouchstart="board_ontouchstart()" ontouchmove="board_ontouchmove()" ontouchend="board_ontouchend()" ontouchcancel="board_ontouchcancel()" ></canvas>`);
      all.push(`<div class='INSIDECONTAINER'>`);
      if(1){
        if(o.choice){
          let title = this.uncode(o.style,o.title).trim();
          let text = this.to_choice(o.style,o.body,o.choice).trim();
          all.push(`<div class='PARAGRAPH NORMAL' style='font-size:0.8em;'> ${this.icon_solution} <i>${title}</i> &#160; ${text} </div>`)
        }else{
          let title = this.uncode(o.style,o.title).trim();
          let text = this.uncode(o.style,this.join_para(o.body)).trim();
          all.push(`<div class='PARAGRAPH NORMAL' style='font-size:0.8em;'> ${this.icon_solution} <i>${title}</i> &#160; ${text} </div>`)
        }
        o.contents.forEach((x) => {
          //'x' is a block
          let html = this.translate_block(x);
          all.push('');
          all.push(html.trim());
        });
      }
      all.push(`</div>`);
      all.push('</article>');
      all.push('');
    })
    //
    //NOTE: end
    //
    return all.join('\n');
  }
  to_titlepage(pages){
    let title     = this.parser.conf_to_string('title','Untitled');
    let subtitle  = this.parser.conf_to_string('subtitle')
    let institute = this.parser.conf_to_string('institute');
    let author    = this.parser.conf_to_string('author');
    var style     = this.parser.style;
    var date      = new Date().toLocaleDateString();
    let data = `<article row='0' class='SLIDE COVER' style='' >
    <div class='FRONTMATTERTITLE' >${this.uncode(style,title)}</div>
    <div class='FRONTMATTERSUBTITLE' >${this.uncode(style,subtitle)}</div>
    <div class='FRONTMATTERINSTITUTE' >${this.uncode(style,institute)}</div>
    <div class='FRONTMATTERAUTHOR' >${this.uncode(style,author)}</div>
    <div class='FRONTMATTERDATE' >${this.uncode(style,date)}</div>
    <div class='BOTTOMCONTAINER'><div class='PAGENUM'> / </div></div>
    </article>
    `;
    pages.push(1);
    return data;
  }
  to_choice(style,body,check){
    body = body.filter((s) => s.length)
    var all = [];
    var re_word = /^(\w+)/;
    var v;
    var checks = check?check.split('/'):[];
    all.push(`<ul style='margin-top:0;margin-bottom:0;list-style:none; padding:0;'>`);
    body.forEach((s) => {
      var start;
      if((v=re_word.exec(s))!==null){
        start = v[1];
      }
      if(this.is_in_list(start,checks)){
        all.push(`<li> ${this.uchar_checkboxc} ${this.uncode(style,s)} </li>`)
      }else{
        all.push(`<li> ${this.uchar_checkboxo} ${this.uncode(style,s)} </li>`)
      }
    })
    all.push(`</ul>`)
    return all.join('\n')
  }
  to_fontsize(length){
    var fontsize = '';
    if( length > 16 ){
      fontsize = '90%';
    }
    if( length > 18 ){
      fontsize = '80%';
    }
    if( length > 20 ){
      fontsize = '70%';
    }
    if( length > 24 ){
      fontsize = '60%';
    }
    return fontsize;
  }
  to_sidesvg_for_id(id,toc,max_n=30){
    var all = [];
    var where_j = -1;
    toc.forEach((p,j) => {
      if(p.id==id){
        where_j = j;
      }
    });
    var dj = 0;
    var dy = 0;
    if(where_j > max_n){
      dj = where_j - max_n;
      dy = dj*10;
    }
    toc.forEach((p,j) => {
      let y = j*10;
      if(where_j==j){
        all.push(`<rect x="0" y="${y-dy}" width="88" height="10" stroke="none" fill="#124A47"/>`);
        var fontcolor = '#DDEEFF';
      }else{
        var fontcolor = '#124A47';
      }
      let x = 5;
      let icon = '';
      if(p.issub){
        x += 0;
        icon = this.icon_folder;
      }
      all.push(`<text id="svg${p.id}" x="${x}" y="${y-dy+8}" stroke="none" fill="${fontcolor}" font-size="5pt" >${p.order} ${icon} ${this.smooth(p.title)} ${p.posticon} </text>`)
    })
    var text = all.join('\n');
    text = (`<svg xmlns="http://www.w3.org/2000/svg" width="88" height="360" viewBox="0 0 88 360"> ${text} </svg>`);
    return text
  }
  to_sidemap_for_id(id,toc,where_j,max_n){
    var all = [];
    all.push(`<map name='map${id}'>`);
    toc.forEach((p,j) => {
      // 508 <map name='shapesmap'><area shape='rect' coords='0 0 88 10' href='http:www.google.com'/> </map>
      if(where_j > max_n){
        let dn = where_j - max_n;
        all.push(`<area shape='rect' coords='0 ${(j-dn)*10} 88 ${(j-dn)*10+10}' href='#frame-${p.id}'/>`);
      }else{
        all.push(`<area shape='rect' coords='0 ${j*10} 88 ${j*10+10}' href='#frame-${p.id}'/>`);
      }
    })
    all.push(`</map>`);
    return all.join('\n')
  }
  to_tool_contents(boardid){
    return `\
         <div id='text-${boardid}' class='TOOLMENU' style='display:flex;flex-direction:row;align-items:flex-start;justify-content:flex-start;flex-wrap:wrap;width:88px;height:34px;' >
           <textarea  class='ONE TE'      name='${boardid}'  type='text'      onchange="board_onetechanged(this.name,this)" > </textarea>
         </div>

         <div id='tool-${boardid}' class='TOOLMENU' style='display:flex;flex-direction:row;align-items:flex-start;justify-content:flex-start;flex-wrap:wrap;width:357px;height:34px;' >
           <button class='ONE OP DOT'                  name='${boardid}'  data='hand'      onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["hand"   ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='pencil'    onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["pencil" ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='eraser'    onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["eraser" ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='smudge'    onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["smudge" ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='select'    onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["select" ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='poly'      onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["poly"   ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='rect'      onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["rect"   ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='elli'      onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["elli"   ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='ball'      onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["ball"   ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='cplane'    onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["cplane" ]} </button>
           <button class='ONE OP'                      name='${boardid}'  data='xyplane'   onclick="board_oneopclicked(this.name,this)" > ${all_op_icons["xyplane"]} </button>

           <button class='ONE CL C0 DOT'               name='${boardid}'  data='0'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>         
           <button class='ONE CL C1'                   name='${boardid}'  data='1'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        
           <button class='ONE CL C2'                   name='${boardid}'  data='2'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        
           <button class='ONE CL C3'                   name='${boardid}'  data='3'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        
           <button class='ONE CL C4'                   name='${boardid}'  data='4'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        
           <button class='ONE CL C5'                   name='${boardid}'  data='5'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        
           <button class='ONE CL C6'                   name='${boardid}'  data='6'         onclick="board_oneclclicked(this.name,this)" > &#x2B24;                   </button>        

           <button class='ONE ST'                      name='${boardid}'  data='0'         onclick="board_onestclicked(this.name,this)" > ${all_st_icons[0        ]} </button>
           <button class='ONE ST DOT'                  name='${boardid}'  data='1'         onclick="board_onestclicked(this.name,this)" > ${all_st_icons[1        ]} </button>
           <button class='ONE ST'                      name='${boardid}'  data='2'         onclick="board_onestclicked(this.name,this)" > ${all_st_icons[2        ]} </button>

           <button class='ONE AT'                      name='${boardid}'  data='fopen'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["fopen"  ]} </button>  
           <button class='ONE AT'                      name='${boardid}'  data='dload'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["dload"  ]} </button>         
           <button class='ONE AT'                      name='${boardid}'  data='uload'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["uload"  ]} </button>  
           <button class='ONE AT'                      name='${boardid}'  data='acton'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["acton"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='clear'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["clear"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='cropp'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["cropp"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='cutbd'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["cutbd"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='paste'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["paste"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='darkb'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["darkb"  ]} </button> 
           <button class='ONE AT'                      name='${boardid}'  data='zoomo'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["zoomo"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='zoomi'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["zoomi"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='rotcl'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["rotcl"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='rotcr'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["rotcr"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='flipv'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["flipv"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='fliph'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["fliph"  ]} </button>       
           <button class='ONE AT'                      name='${boardid}'  data='bg2fg'     onclick="board_oneatclicked(this.name,this)" > ${all_at_icons["bg2fg"  ]} </button>       
       </div>
       <input id='fopen-${boardid}' name='${boardid}'  type='file' style='display:none' onchange='board_fopen_clicked(this.name,this)'/>
       <a     id='dload-${boardid}' name='${boardid}'  type='text' style='display:none' onclick="board_dload_clicked(this.name,this)">&#x2B73;</a>
       <form name='${boardid}' id='form-${boardid}' action='/echo' method='post' style='display:none' onsubmit='board_onsubmitclicked(this.name,this)' >
         <button   style='display:none' id='submit-${boardid}' name='submit'></button>
         <textarea style='display:none' id='png-${boardid}' name='png'></textarea>
         <textarea style='display:none' id='url-${boardid}' name='url'></textarea>
       </form>
       `;
  }
  ////////////////////////////////////////////////////////////////////////
  //
  //
  //
  ////////////////////////////////////////////////////////////////////////
  to_setup_script(){
    return `\
    allnames=['AliceBlue','AntiqueWhite','Aqua','Aquamarine','Azure','Beige','Bisque','Black','BlanchedAlmond','Blue','BlueViolet','Brown','BurlyWood','CadetBlue','Chartreuse','Chocolate','Coral','CornflowerBlue','Cornsilk','Crimson','Cyan','DarkBlue','DarkCyan','DarkGoldenRod','DarkGray','DarkGrey','DarkGreen','DarkKhaki','DarkMagenta','DarkOliveGreen','DarkOrange','DarkOrchid','DarkRed','DarkSalmon','DarkSeaGreen','DarkSlateBlue','DarkSlateGray','DarkSlateGrey','DarkTurquoise','DarkViolet','DeepPink','DeepSkyBlue','DimGray','DimGrey','DodgerBlue','FireBrick','FloralWhite','ForestGreen','Fuchsia','Gainsboro','GhostWhite','Gold','GoldenRod','Gray','Grey','Green','GreenYellow','HoneyDew','HotPink','IndianRed','Indigo','Ivory','Khaki','Lavender','LavenderBlush','LawnGreen','LemonChiffon','LightBlue','LightCoral','LightCyan','LightGoldenRodYellow','LightGray','LightGrey','LightGreen','LightPink','LightSalmon','LightSeaGreen','LightSkyBlue','LightSlateGray','LightSlateGrey','LightSteelBlue','LightYellow','Lime','LimeGreen','Linen','Magenta','Maroon','MediumAquaMarine','MediumBlue','MediumOrchid','MediumPurple','MediumSeaGreen','MediumSlateBlue','MediumSpringGreen','MediumTurquoise','MediumVioletRed','MidnightBlue','MintCream','MistyRose','Moccasin','NavajoWhite','Navy','OldLace','Olive','OliveDrab','Orange','OrangeRed','Orchid','PaleGoldenRod','PaleGreen','PaleTurquoise','PaleVioletRed','PapayaWhip','PeachPuff','Peru','Pink','Plum','PowderBlue','Purple','RebeccaPurple','Red','RosyBrown','RoyalBlue','SaddleBrown','Salmon','SandyBrown','SeaGreen','SeaShell','Sienna','Silver','SkyBlue','SlateBlue','SlateGray','SlateGrey','Snow','SpringGreen','SteelBlue','Tan','Teal','Thistle','Tomato','Turquoise','Violet','Wheat','White','WhiteSmoke','Yellow','YellowGreen'];
    allhexcs=['f0f8ff','faebd7','00ffff','7fffd4','f0ffff','f5f5dc','ffe4c4','000000','ffebcd','0000ff','8a2be2','a52a2a','deb887','5f9ea0','7fff00','d2691e','ff7f50','6495ed','fff8dc','dc143c','00ffff','00008b','008b8b','b8860b','a9a9a9','a9a9a9','006400','bdb76b','8b008b','556b2f','ff8c00','9932cc','8b0000','e9967a','8fbc8f','483d8b','2f4f4f','2f4f4f','00ced1','9400d3','ff1493','00bfff','696969','696969','1e90ff','b22222','fffaf0','228b22','ff00ff','dcdcdc','f8f8ff','ffd700','daa520','808080','808080','008000','adff2f','f0fff0','ff69b4','cd5c5c','4b0082','fffff0','f0e68c','e6e6fa','fff0f5','7cfc00','fffacd','add8e6','f08080','e0ffff','fafad2','d3d3d3','d3d3d3','90ee90','ffb6c1','ffa07a','20b2aa','87cefa','778899','778899','b0c4de','ffffe0','00ff00','32cd32','faf0e6','ff00ff','800000','66cdaa','0000cd','ba55d3','9370db','3cb371','7b68ee','00fa9a','48d1cc','c71585','191970','f5fffa','ffe4e1','ffe4b5','ffdead','000080','fdf5e6','808000','6b8e23','ffa500','ff4500','da70d6','eee8aa','98fb98','afeeee','db7093','ffefd5','ffdab9','cd853f','ffc0cb','dda0dd','b0e0e6','800080','663399','ff0000','bc8f8f','4169e1','8b4513','fa8072','f4a460','2e8b57','fff5ee','a0522d','c0c0c0','87ceeb','6a5acd','708090','708090','fffafa','00ff7f','4682b4','d2b48c','008080','d8bfd8','ff6347','40e0d0','ee82ee','f5deb3','ffffff','f5f5f5','ffff00','9acd32'];
    all_smears = {};
    all_colors = ['SlateGray', 'RoyalBlue', 'OliveDrab', 'DarkOrchid', 'Turquoise', 'DarkOrange', 'DeepPink'];
    all_strokes = [1,1.6,3.0];
    all_shapes = ['rect','triangle','ellipse','pentagon','hexagon','line'];
    for(let i=0; i < allnames.length; ++i){
      var name = allnames[i];
      var hexc = allhexcs[i];
      if(typeof hexc == 'string' && hexc.length==6){
        let r = '0x' + hexc.substr(0,2);
        let g = '0x' + hexc.substr(2,2);
        let b = '0x' + hexc.substr(4,2);
        r = parseInt(r);
        g = parseInt(g);
        b = parseInt(b);
        all_smears[name]=[r,g,b];
      }
    }
    function paint_canvas(imgid,canvasid){
      var img = document.getElementById(imgid);
      var canvas = document.getElementById(canvasid);
      var ctx = canvas.getContext('2d');
      if(1){
        ctx.clearRect(0,0, canvas.width,canvas.height);
        ctx.drawImage(img, 0,0,parseInt(canvas.width),parseInt(canvas.height));
        canvas.style.backgroundImage = '';
      } 
    }
    function board_assert(ctx,canvas){
      canvas.style.cursor = 'crosshair';
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      if(!ctx.cake){
        let cake = board_create_cake(ctx,canvas);
        ctx.cake = cake;
        board_enter(ctx,canvas);
      }
    }
    function board_create_cake(ctx,canvas){ 
      let myundo = {s0:[]};
      let mybasis = {x:0,y:0,w:0,h:0,dx:0,dy:0,dw:0,dh:0,s:null,face:null,rsize:0};
      ///CORE
      let cake = {};
      cake.disabled = 0;
      cake.s = null;
      cake.myundo = myundo;
      cake.mybasis = mybasis;
      cake.myop = 'hand';
      cake.mycolorid = 0;
      cake.mystrokeid = 1;
      cake.myshapeid = 0;
      cake.myfs = 12;
      cake.mytext = '';
      cake.myaction = 0;
      cake.myrotation = 0;
      cake.myflipv = 0;
      cake.myfliph = 0;
      cake.myzoom = 0;
      return cake;          
    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function getSiblings(e){
      // for collecting siblings
      let siblings = []; 
      // if no parent, return no sibling
      if(!e.parentNode) {
          return siblings;
      }
      // first child of the parent node
      let sibling  = e.parentNode.firstChild;
      // collecting siblings
      while (sibling) {
        if (sibling.nodeType === 1 && sibling !== e) {
          siblings.push(sibling);
        }
        sibling = sibling.nextSibling;
      }
      return siblings;
    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function board_oneopclicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      if(!ctx.cake.myop){
        var sibs = getSiblings(e);
        sibs.forEach((v)=>{
          if(v.classList.contains('CL') && v.getAttribute('data')==ctx.cake.mycolorid){
            v.classList.add('DOT');
          }
          if(v.classList.contains('ST') && v.getAttribute('data')==ctx.cake.mystrokeid){
            v.classList.add('DOT');
          }
          if(v.classList.contains('SH') && v.getAttribute('data')==ctx.cake.myshapeid){
            v.classList.add('DOT');
          }
          if(v.classList.contains('AT')){
            v.disabled = false;       
          }
        });
        ctx.cake.myop = e.getAttribute('data');
        board_enter(ctx,canvas);
        board_redraw(ctx,canvas);
        e.classList.add('DOT');
      }else{
        board_leave(ctx,canvas);
        ctx.cake.myop = e.getAttribute('data');
        board_enter(ctx,canvas);
        board_redraw(ctx,canvas);
        var sibs = getSiblings(e);
        sibs.forEach((v)=>{
          if(v.classList.contains('OP')){
            v.classList.remove('DOT');
          }
        });
        e.classList.add('DOT');
      }
    }
    function board_oneclclicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      if(ctx.cake.myop){
        ctx.cake.mycolorid = e.getAttribute('data');
        board_coloridchanged(ctx,canvas);
        board_redraw(ctx,canvas);
        var sibs = getSiblings(e);
        sibs.forEach((v)=>{
          if(v.classList.contains('CL')){
            v.classList.remove('DOT');
          }
        });
        e.classList.add('DOT');
      }
    }
    function board_onestclicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      if(ctx.cake.myop){
        ctx.cake.mystrokeid = e.getAttribute('data');
        board_strokeidchanged(ctx,canvas);
        board_redraw(ctx,canvas);
        var sibs = getSiblings(e);
        sibs.forEach((v)=>{
          if(v.classList.contains('ST')){
            v.classList.remove('DOT');
          }
        });
        e.classList.add('DOT');
      }
    }
    function board_oneshclicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      if(ctx.cake.myop){
        ctx.cake.myshapeid = e.getAttribute('data');
        board_shapeidchanged(ctx,canvas);
        board_redraw(ctx,canvas);
        var sibs = getSiblings(e);
        sibs.forEach((v)=>{
          if(v.classList.contains('SH')){
            v.classList.remove('DOT');
          }
        });
        e.classList.add('DOT');
      }
    }
    function board_oneatclicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      if(ctx.cake.myop){
        var v = e.getAttribute('data');
        switch(v){
          case 'fg2bg': {
            board_fg2bg(ctx,canvas);
            break;
          }
          case 'bg2fg': {
            board_bg2fg(ctx,canvas);
            break;
          }
          case 'clear': {
            board_clear(ctx,canvas);
            break;
          }
          case 'cropp': {
            board_cropp(ctx,canvas);
            break;
          }
          case 'fopen': {
            let input = document.getElementById('fopen-'+canvas.id);//this is a Input element
            input.click();
            break;
          }
          case 'dload': {
            let a = document.getElementById('dload-'+canvas.id);//this is a hyperlink element
            a.click();
            break;
          }
          case 'zoomo': {
            board_zoomo(ctx,canvas);
            break;
          }
          case 'zoomi': {
            board_zoomi(ctx,canvas);
            break;
          }
          case 'rotcl': {
            board_rotcl(ctx,canvas);
            break;
          }
          case 'rotcr': {
            board_rotcr(ctx,canvas);
            break;
          }
          case 'flipv': {
            board_flipv(ctx,canvas);
            break;
          }
          case 'fliph': {
            board_fliph(ctx,canvas);
            break;
          }
          case 'acton': {
            board_action(ctx,canvas);
            break;
          }
          case 'cutbd': {
            board_cutbd(ctx,canvas);
            break;
          }
          case 'paste': {
            board_paste(ctx,canvas);
            break;
          }
          case 'uload': {
            //console.log('uload',name);
            let buttonid = ("submit-"+name);
            let button = document.getElementById(buttonid);
            //console.log(buttonid,button);
            button.click();
            break;
          }
          case 'darkb': {
            canvas.classList.toggle('WHITE');
            break;
          }
        }
        board_redraw(ctx,canvas);
      }
    }
    function board_onetechanged(name,e){
      var value = e.value;
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_assert(ctx,canvas);
      board_settext(value,ctx,canvas);
      board_redraw(ctx,canvas);
    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function board_dload_clicked(name,e){
      var fname = 'image.png';
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      board_leave(ctx,canvas);
      e.download = fname;
      e.href = canvas.toDataURL();
      board_enter(ctx,canvas);
    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function board_fopen_clicked(name,e){
      var canvas = document.getElementById(name);
      var ctx = canvas.getContext('2d');
      if(e.files[0]){
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function(){
          var o = ctx.cake;
          o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.drawImage(img, 0,0);
          o.mybasis.clipboard = ctx.getImageData(0,0, img.width,img.height);
          o.mybasis.x = 0;
          o.mybasis.y = 0;
          o.mybasis.w = img.width;
          o.mybasis.h = img.height;
          ctx.putImageData(o.mybasis.s, 0,0);
          ctx.drawImage(img, 0,0);
          board_redraw(ctx,canvas);
        }
        var reader = new FileReader();
        reader.onload = function(){
          var dataURL = reader.result;
          img.src = dataURL;
        }
        reader.readAsDataURL(e.files[0]);
      }
    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function board_onebuttclicked(name,e){
      var canvas = document.getElementById(name);
      var butt = document.getElementById("butt-"+name);
      var tool = document.getElementById("tool-"+name);
      if(canvas.style.visibility == 'hidden'){
        canvas.style.visibility = 'visible';
        butt.classList.add("VISIBLE");  
        tool.classList.add("VISIBLE");  
      } else {
        canvas.style.visibility = 'hidden';
        butt.classList.remove("VISIBLE");  
        tool.classList.remove("VISIBLE");  
      }
    }
    function board_onsubmitclicked(name,e){
      var form = e;
      var canvas = document.getElementById(name);
      var boardpng = canvas.getAttribute('data-boardpng');
      var e_png  = form.elements["png"];
      var e_url  = form.elements["url"];
      if(boardpng){
        var s      = canvas.toDataURL();                
        e_png.value = boardpng;
        e_url.value = s;
        var png = boardpng;
        var url = s;
      }else{
        var s      = canvas.toDataURL();                
        e_png.value = 'image.png';
        e_url.value = s;
        var png = 'image.png';
        var url = s;
      }
      event.preventDefault();
      // console.log(form);
      // console.log(form.elements)
      // console.log('using fetch');
      // fetch(form.action, {method:'post', body: new FormData(form)});
      fetch(form.action, { method:'post', body: JSON.stringify({data:"MY DATA",png,url}), headers: { "Content-Type": "application/json" } }).then(r => r.text()).then(text => alert(text));

    }
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    function board_onshowdropmenu(){
      event.target.focus();
    }
    function board_curr_color(ctx,canvas){
      var id = ctx.cake.mycolorid;
      id = Math.abs(id);
      id = id % all_colors.length;
      return all_colors[id]; 
    }
    function board_curr_stroke(ctx,canvas){
      var id = ctx.cake.mystrokeid;
      id = Math.abs(id);
      id = id % all_strokes.length;
      return all_strokes[id]; 
    }
    function board_get_color(id,ctx,canvas){
      id = Math.abs(id);
      id = id % all_colors.length;
      return all_colors[id]; 
    }
    function board_get_stroke(id,ctx,canvas){
      id = Math.abs(id);
      id = id % all_strokes.length;
      return all_strokes[id]; 
    }
    function board_midpoint(c1,c2,where=0.5){      
      let x = c1[0]+(c2[0]-c1[0])*where;                     
      let y = c1[1]+(c2[1]-c1[1])*where;                     
      return [x,y];
    }
    function board_get_ball_points(v,w,h,ctx,canvas){
      let points = [];
      let m = Math.PI/180;
      switch(v){
      case 'line':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:-30,y:0,x1:-30,y1:0});
        points.push({op:'L',x:+30,y:0,x1:+30,y1:0});
        break;
      case 'tri':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:0,y:-30,x1:0,y1:-30});
        points.push({op:'L',x:+26,y:+15,x1:+26,y1:+15});
        points.push({op:'L',x:-26,y:+15,x1:-26,y1:+15});
        points.push({op:'z'});
        break;
      case 'triur':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:-30,y:-30,x1:-30,y1:-30});
        points.push({op:'L',x:+30,y:+30,x1:+30,y1:+30});
        points.push({op:'L',x:-30,y:+30,x1:-30,y1:+30});
        points.push({op:'z'});
        break;
      case 'rect':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:-30,y:+30,x1:-30,y1:+30});
        points.push({op:'L',x:+30,y:+30,x1:+30,y1:+30});
        points.push({op:'L',x:+30,y:-30,x1:+30,y1:-30});
        points.push({op:'L',x:-30,y:-30,x1:-30,y1:-30});
        points.push({op:'z'});
        break;
      case 'pentagon':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:Math.sin(0)*30,y:-Math.cos(0)*30,x1:Math.sin(0)*30,y1:-Math.cos(0)*30});
        points.push({op:'L',x:Math.sin(m*72)*30,y:-Math.cos(m*72)*30,x1:Math.sin(m*72)*30,y1:-Math.cos(m*72)*30});
        points.push({op:'L',x:Math.sin(m*144)*30,y:-Math.cos(m*144)*30,x1:Math.sin(m*144)*30,y1:-Math.cos(m*144)*30});
        points.push({op:'L',x:Math.sin(m*216)*30,y:-Math.cos(m*216)*30,x1:Math.sin(m*216)*30,y1:-Math.cos(m*216)*30});
        points.push({op:'L',x:Math.sin(m*288)*30,y:-Math.cos(m*288)*30,x1:Math.sin(m*288)*30,y1:-Math.cos(m*288)*30});
        points.push({op:'z'});
        break;
      case 'hexagon':
        points.push({op:'',x:0,y:0});
        points.push({op:'M',x:Math.sin(0)*30,y:-Math.cos(0)*30,x1:Math.sin(0)*30,y1:-Math.cos(0)*30});
        points.push({op:'L',x:Math.sin(m*60)*30,y:-Math.cos(m*60)*30,x1:Math.sin(m*60)*30,y1:-Math.cos(m*60)*30});
        points.push({op:'L',x:Math.sin(m*60*2)*30,y:-Math.cos(m*60*2)*30,x1:Math.sin(m*60*2)*30,y1:-Math.cos(m*60*2)*30});
        points.push({op:'L',x:Math.sin(m*60*3)*30,y:-Math.cos(m*60*3)*30,x1:Math.sin(m*60*3)*30,y1:-Math.cos(m*60*3)*30});
        points.push({op:'L',x:Math.sin(m*60*4)*30,y:-Math.cos(m*60*4)*30,x1:Math.sin(m*60*4)*30,y1:-Math.cos(m*60*4)*30});
        points.push({op:'L',x:Math.sin(m*60*5)*30,y:-Math.cos(m*60*5)*30,x1:Math.sin(m*60*5)*30,y1:-Math.cos(m*60*5)*30});
        points.push({op:'z'});
        break;
      case 'circle':
        points.push({op:'',x:0,y:0});
        points.push({op:'e',x1:0,y1:0,rx:30,ry:30,sAngle:0,eAngle:Math.PI*2,anticlockflag:0});
        points.push({op:'',x:30,y:0});
        points.push({op:'',x:0,y:30});
        points.push({op:'',x:-30,y:0});
        points.push({op:'',x:0,y:-30});
        points.push({op:'z'});
        break;
      }
      return points;
    }
    function board_get_ball_corners(v,w,h,ctx,canvas){
      var corners = [];
      corners.push({x:-30,y:-30});
      corners.push({x:+30,y:-30});
      corners.push({x:+30,y:+30});
      corners.push({x:-30,y:+30});
      return corners;
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function board_wiggleidchanged(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='pencil'){
      } 
    }
    function board_coloridchanged(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='cplane'){
        o.mycplane.mycolorid = o.mycolorid;
      } 
      if(o.myop=='ball'){
        if(o.myball.hitball){
          o.myball.hitball.colorid = o.mycolorid;
        }
      } 
    }
    function board_strokeidchanged(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='cplane'){
        o.mycplane.mystrokeid = o.mystrokeid;
      } 
      if(o.myop=='ball'){
        if(o.myball.hitball){
          o.myball.hitball.strokeid = o.mystrokeid;
        }
      } 
    }
    function board_shapeidchanged(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='ball'){
        if(o.myball.hitball){
          o.myball.hitball.shapeid = o.myshapeid;
        }
      } 
    }
    function board_enter(ctx,canvas){
      var o = ctx.cake;          
      o.myaction   = 0;
      o.myrotation = 0;
      o.myflipv    = 0;
      o.myfliph    = 0;
      o.myzoom     = 0;
      if(o.myop=='hand'){ // hand enter     
        console.log('board_enter for hand');
        canvas.classList.remove('CAKE');  
      }
      if(o.myop=='select'){ //board_enter select
        ctx.resetTransform();
        //o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
        //o.mybasis.clipboard = null;
        //o.mybasis.face = null;
        //o.mybasis.x = 0;
        //o.mybasis.y = 0;
        //o.mybasis.w = 0;
        //o.mybasis.h = 0;
        if(!o.mybasis.s){
          o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
        }
      }
      if(o.myop=='pencil'){  //board_enter pencil
        ctx.resetTransform();
        if(!o.mypencil){
          o.mypencil = {};
          o.mypencil.x = 0;
          o.mypencil.y = 0;
          o.mypencil.w = 0;
          o.mypencil.h = 0;
        }
      }
      if(o.myop=='poly'    // poly enter        
        || o.myop=='rect'    // poly enter        
        || o.myop=='elli'){  // poly enter        
        ctx.resetTransform();
        if(!o.mypoly){
          o.mypoly = {};
          o.mypoly.s = null;
          o.mypoly.polypts = [];
          o.mypoly.x = 0;
          o.mypoly.y = 0;
          o.mypoly.w = 0;
          o.mypoly.h = 0;
        }
      }
      if(o.myop=='smudge'){  //board_enter smudge
        ctx.resetTransform();
        if(!o.mysmudge){
          o.mysmudge = {};
          o.mysmudge.x = 0;
          o.mysmudge.y = 0;
          o.mysmudge.w = 0;
          o.mysmudge.h = 0;
        }
      }
      if(o.myop=='eraser'){  // eraser enter        
        ctx.resetTransform();
        if(!o.myeraser){
          o.myeraser = {};
          o.myeraser.x = 0;
          o.myeraser.y = 0;
          o.myeraser.w = 0;
          o.myeraser.h = 0;
        }
      }
      if(o.myop=='cplane'){ //board_enter cplane
        if(!o.mycplane){
          o.mycplane = {};
          o.mycplane.path_handle = null;
          o.mycplane.pointisinhandle = false;
          o.mycplane.ishandledragged = 0;
          o.mycplane.mystrokeid = o.mystrokeid;
          o.mycplane.mycolorid = o.mycolorid;
          o.mycplane.grid = 30;
          o.mycplane.origin_x = Math.round(canvas.width/2);
          o.mycplane.origin_y = Math.round(canvas.height/2);
          o.mycplane.zoom_factor = 1.0;
          o.mycplane.scale_factor = 1.0;
          o.mycplane.rotate_ang = 0;//in degrees clockwise-rotation is positive
          o.mycplane.move_x = 0.0;//pixels
          o.mycplane.move_y = 0.0;//pixels
          o.mycplane.snap_type = '';
          o.mycplane.ismultiply = 0;
        }
      }
      if(o.myop=='xyplane'){ //board_enter xyplane
        if(!o.myxyplane){
          o.myxyplane = {};
          o.myxyplane.grid = 30;
          o.myxyplane.origin_x = Math.round(canvas.width/2);
          o.myxyplane.origin_y = Math.round(canvas.height/2);
          o.myxyplane.zoom_factor = 1.0;
          o.myxyplane.info_tt = '';
          o.myxyplane.info_xi = 0;
          o.myxyplane.info_yi = 0;
          o.myxyplane.y_intercepts = [];
          o.myxyplane.x_intercepts = [];
        }
      }
      if(o.myop=='ball'){ // ball enter     
        if(!o.myball){
          o.myball = {};
          o.myball.shapeid = 0;
          o.myball.balls = [];
          o.myball.hitball = null;
          o.myball.selection = [];
        }
      }
    }
    function board_leave(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='hand'){ // hand enter       
        console.log('board_leave for hand');
        canvas.classList.add('CAKE');
      }
      if(o.myop=='select'){ //board_leave
        if(o.mybasis.s){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.s, 0,0);
          o.mybasis.s = null;
        }
        if(o.mybasis.face){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.face, 0,0);
          o.mybasis.face = null;
        }
        o.mybasis.clipboard = null;
      }
      if(o.myop=='poly'   // poly leave
        || o.myop=='rect'   // poly leave
        || o.myop=='elli'){ // poly leave
        if(o.mypoly){
          o.mypoly.s = null;
          o.mypoly.polypts = [];
        }
      }
      if(o.myop=='cplane'){ //board_leave
        if(o.mycplane){
          o.mycplane.s = null;
          ctx.resetTransform();
        }
      }
      if(o.myop=='xyplane'){ //board_leave
        if(o.myxyplane){
          ctx.resetTransform();
        }
      }
      if(o.myop=='ball'){ // ball leave       
        if(o.myball){
          o.myball.s = null;
          ctx.resetTransform();
        }
      }
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function board_redraw(ctx,canvas){
      ///
      ///console.log('board_redraw','op=',ctx.cake.myop,'id=',canvas.id);
      ///
      var o = ctx.cake;          
      ctx.resetTransform();
      if(ctx.cake.myop=='select'){ //board_redraw select
        ctx.resetTransform();
        if(o.myaction){
          o.myaction = 0;
          o.mybasis.rsize += 1;
          o.mybasis.rsize %= 2;
        }
        let {x,y,w,h} = o.mybasis;
        if(o.mybasis.s){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.s,0,0);
        }
        if(o.cutbd){              
          if(o.mybasis.face){
            ctx.clearRect(0,0, canvas.width,canvas.height);
            ctx.putImageData(o.mybasis.face,0,0);
            o.mybasis.face = null;
          }
          if(w && h){
            o.mybasis.clipboard = ctx.getImageData(x,y, w,h);                       
            ctx.clearRect(x,y, w,h);
            o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
          }
          o.cutbd = 0;
        }
        o.mybasis.face = null;
        if(w && h){
          if(o.mybasis.clipboard){
            if(o.mybasis.w == o.mybasis.clipboard.width && o.mybasis.h == o.mybasis.clipboard.height){
              PutImageData(o.mybasis.clipboard, x,y,ctx);
              o.mybasis.face = ctx.getImageData(0,0, canvas.width,canvas.height);
            }else{
              let odata = o.mybasis.clipboard;
              let iwidth = o.mybasis.w;
              let iheight = o.mybasis.h;
              let ndata = ResizeImageData(odata,iwidth,iheight,ctx);
              PutImageData(ndata, x,y,ctx);
              o.mybasis.face = ctx.getImageData(0,0, canvas.width,canvas.height);
            }
          }
          ctx.save();
          ctx.globalAlpha = 1.0;   
          ctx.lineWidth = 1;   
          ctx.strokeStyle = 'gray';
          ctx.globalCompositeOperation = 'xor';
          if(o.mybasis.clipboard){
          }else{
            ctx.setLineDash([3.0,3.0]);
          }
          ctx.strokeRect(x,y,w,h);
          ctx.restore();
          if(o.mybasis.rsize){
            let gap = Math.min(10,0.25*w);
            let dep = Math.min(10,0.25*h);
            ctx.save();
            ctx.strokeStyle = 'black';
            ctx.globalAlpha = 1.0;   
            ctx.lineWidth = 1;   
            let x0 = x;
            let y0 = y;
            let x1 = x+w;
            let y1 = y;
            let x2 = x+w;
            let y2 = y+h;
            let x3 = x;
            let y3 = y+h;
            x0 -= 1;
            y0 -= 1;
            x1 += 1;
            y1 -= 1;
            x2 += 1;
            y2 += 1;
            x3 -= 1;
            y3 += 1;
            ctx.beginPath();
            ctx.moveTo(x0,y0); ctx.lineTo(x0,     y0+dep);
            ctx.moveTo(x0,y0); ctx.lineTo(x0+gap, y0    );
            ctx.moveTo(x1,y1); ctx.lineTo(x1,     y1+dep);
            ctx.moveTo(x1,y1); ctx.lineTo(x1-gap, y1    );
            ctx.moveTo(x2,y2); ctx.lineTo(x2,     y2-dep);
            ctx.moveTo(x2,y2); ctx.lineTo(x2-gap, y2    );
            ctx.moveTo(x3,y3); ctx.lineTo(x3,     y3-dep);
            ctx.moveTo(x3,y3); ctx.lineTo(x3+gap, y3    );
            ctx.stroke();
            ctx.restore();
          }
        }
      }
      if(ctx.cake.myop=='pencil' ){ //board_redraw pencil
      }
      if(ctx.cake.myop=='poly' 
        || ctx.cake.myop=='rect'
        || ctx.cake.myop=='elli'){ // poly redraw     
      }
      if(ctx.cake.myop=='smudge' ){ //board_redraw smudge
      }
      if(ctx.cake.myop=='eraser' ){ //board_redraw eraser
      }
      if(ctx.cake.myop=='cplane'){ // cplane redraw
        ctx.resetTransform();
        ctx.clearRect(0,0, canvas.width,canvas.height);
        var double_flag = 0;
        var grid = o.mycplane.grid;
        if(o.myzoom > 0){
          ///zoomi
          o.mycplane.zoom_factor *= 1.05;
          o.myzoom = 0;
        }else if(o.myzoom < 0){
          ///zoomo
          o.mycplane.zoom_factor /= 1.05;
          o.myzoom = 0;
        }
        if(o.mycplane.rotate_ang!=0 || o.mycplane.scale_factor!=1|| o.mycplane.move_x!=0|| o.mycplane.move_y!=0){
          double_flag = 1;
        }
        let ismultiply = (o.myaction%2)?1:0;
        if(o.mycplane.ismultiply != ismultiply){
          o.mycplane.ismultiply = ismultiply;
          o.mycplane.move_x = 0;
          o.mycplane.move_y = 0;
          o.mycplane.scale_factor = 1;
          o.mycplane.rotate_ang = 0;
        }
        ctx.translate(+o.mycplane.origin_x,+o.mycplane.origin_y);
        ctx.scale(+o.mycplane.zoom_factor,+o.mycplane.zoom_factor);
        var val_real = 0;
        var val_imag = 0;
        var v = null;
        var s = o.mytext.trim();
        var which = 0;
        var mystroke = board_get_stroke(o.mycplane.mystrokeid,ctx,canvas);
        var mycolor = board_get_color(o.mycplane.mycolorid,ctx,canvas);
        if((v=re_scalar_real.exec(s))!==null){
          val_real = parseFloat(v[1]);
          which = 1;
        } else if((v=re_scalar_imag.exec(s))!==null){
          val_imag = parseFloat(v[1]);
          which = 2;
        } else if((v=re_scalar_comp.exec(s))!==null){
          val_real = parseFloat(v[1]);
          val_imag = parseFloat(v[2]);
          which = 3;
        } else if((v=re_scalar_comp2.exec(s))!==null){
          val_real = parseFloat(v[1]);
          val_imag = parseFloat(""+v[2]+"1");
          which = 4;
        } else if((v=re_scalar_comp1.exec(s))!==null){
          val_real = 0;
          val_imag = parseFloat(""+v[1]+"1");
          which = 5;
        }
        ///////////////////////////////////////////////
        ///draw gray grids
        ///////////////////////////////////////////////
        if(1){
          ctx.globalAlpha = 0.5;
          if(canvas.classList.contains('BLACK')){
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
          }else{
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
          }
          ctx.beginPath();
          for (var x=-50; x <= 50; x++) {
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,-50*grid);   
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,+50*grid);   
          }
          for (var y=-50; y <= 50; y++) {
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          ctx.lineWidth = 0.5;
          ctx.stroke();
          //
          // vertical & horizontal axies
          //
          ctx.beginPath();
          if(1){
            var y = 0;
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          if(1){
            var x = 0;
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  -50*grid);   
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  +50*grid);   
          }
          ctx.lineWidth = 1.0;
          ctx.stroke();
          //
          //gray unit circle
          //
          ctx.beginPath();
          ctx.arc(0,0,1*grid,0,Math.PI*2);
          ctx.lineWidth = 1.0;
          ctx.stroke();
          //
          //gray labels
          //
          var fs = o.myfs;
          var text_fs = ""+fs+"px"+" sans-serif";
          ctx.font = text_fs;
          //
          //horizontal labels
          //
          for(var x=-50; x < +50; x++) {
            ctx.fillText(""+x,x*grid,0);
          }
          //
          //vertical labels
          //
          for(var y=-50; y < +50; y++) {
            if(y==0) continue;
            ctx.fillText(""+y+"\u{1D456}",0,-y*grid);
          }
          //
          //gray arrow
          //
          ctx.lineWidth = 1;
          let arrow_x = (val_real)*grid ;
          let arrow_y = -(val_imag)*grid ;
          arrow_x = (val_real)*grid ;
          arrow_y = -(val_imag)*grid ;
          if(Number.isFinite(arrow_x)&&
            Number.isFinite(arrow_y)){
            if(arrow_x == 0 && arrow_y == 0) {
              /// if both zero then dont draw
            } else {
              drawArrow(ctx,0,0,arrow_x,arrow_y,3,1,Math.PI/8,12);
            }
          }
          //
          //gray handle 
          //
          ctx.beginPath();
          var path_handle = new Path2D();
          var r = mystroke*2;
          if(o.mycplane.ismultiply==0){
            path_handle.arc(0,0,r,0,Math.PI*2);
          }else if(o.mycplane.ismultiply==1){
            path_handle.arc(grid,0,r,0,Math.PI*2);
          }
          ctx.fill(path_handle);
          o.mycplane.path_handle = path_handle;
        }
        ///////////////////////////////////////////////
        ///draw blue grids and arrow
        ///////////////////////////////////////////////
        if(1){
          ctx.globalAlpha = 0.5;
          if(o.mycplane.scale_factor < 1){
            let delta = 1 - o.mycplane.scale_factor;//always greater than 0
            ctx.globalAlpha = 0.5 + (delta*0.5);
          }
          if(canvas.classList.contains('BLACK')){
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
          }else{
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
          }
          ctx.rotate(o.mycplane.rotate_ang/180*Math.PI);
          ctx.scale(o.mycplane.scale_factor,o.mycplane.scale_factor);
          ctx.translate(o.mycplane.move_x,o.mycplane.move_y);
          ctx.beginPath();
          for (var x=-50; x <= 50; x++) {
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,-50*grid);   
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,+50*grid);   
          }
          for (var y=-50; y <= 50; y++) {
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          ctx.lineWidth = 0.5;
          ctx.stroke();
          ctx.beginPath();
          //
          // blue axes
          //
          if(1){
            var x = 0;
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,-50*grid);   
            ctx.moveTo(x*grid,0);
            ctx.lineTo(x*grid,+50*grid);   
          }
          if(1){
            var y = 0;
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          ctx.lineWidth = 1.0;
          ctx.stroke();
          //
          //blue arrow
          //
          let reduce_rate = 1;
          if(o.mycplane.scale_factor > 1){
            reduce_rate = Math.log(o.mycplane.scale_factor)+1;
          }
          ctx.lineWidth = 1.0;
          let arrow_x = (val_real)*grid ;
          let arrow_y = -(val_imag)*grid ;
          arrow_x = (val_real)*grid ;
          arrow_y = -(val_imag)*grid ;
          if(Number.isFinite(arrow_x)&&
            Number.isFinite(arrow_y)){
            if(arrow_x == 0 && arrow_y == 0) {
              /// if both zero then dont draw
            } else {
              ctx.fillStyle = mycolor;
              drawArrow(ctx,0,0,arrow_x,arrow_y,3,1,Math.PI/8,12);
            }
          }
          //
          //blue handle 
          //
          ctx.beginPath();
          var r = board_get_stroke(o.mycplane.mystrokeid,ctx,canvas)*2*(1/reduce_rate);
          var f = o.mycplane.zoom_factor * o.mycplane.scale_factor;
          if(f < 1){
            r /= f;
          }
          var path_handle = new Path2D();
          var r = mystroke*2;
          if(o.mycplane.ismultiply==0){
            path_handle.arc(0,0,r,0,Math.PI*2);
          }else if(o.mycplane.ismultiply==1){
            path_handle.arc(grid,0,r,0,Math.PI*2);
          }
          ctx.fillStyle = mycolor;
          ctx.fill(path_handle);
          o.mycplane.path_handle = path_handle;
        }
        //console.log(o.mycplane.origin_x,o.mycplane.origin_y, o.mycplane.move_x, o.mycplane.move_y, o.mycplane.scale_factor, o.mycplane.rotate_ang);
        ctx.globalAlpha = 1.0;
      }
      if(ctx.cake.myop=='xyplane'){ // xyplane redraw     
        ctx.resetTransform();
        ctx.clearRect(0,0, canvas.width,canvas.height);
        const grid = o.myxyplane.grid;
        if(1){
          ctx.globalAlpha = 0.5;
          if(canvas.classList.contains('BLACK')){
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
          }else{
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
          }
          //
          //pick up the zoom in / out setting
          //
          if(o.myzoom > 0){
            o.myxyplane.zoom_factor *= 1.05;
            o.myzoom = 0;
          }else if(o.myzoom < 0){
            o.myxyplane.zoom_factor /= 1.05;
            o.myzoom = 0;
          }
          ctx.translate(+o.myxyplane.origin_x,+o.myxyplane.origin_y);
          ctx.scale(+o.myxyplane.zoom_factor,+o.myxyplane.zoom_factor);
          //
          //always clear out the x/y intercepts as they are each rebuilt during redraw
          //
          o.myxyplane.y_intercepts = [];
          o.myxyplane.x_intercepts = [];
          //
          //find out x-range
          //
          var left = Math.floor((0 - o.myxyplane.origin_x)/(grid*o.myxyplane.zoom_factor));
          var right = Math.ceil((canvas.width - o.myxyplane.origin_x)/(grid*o.myxyplane.zoom_factor));
          var D = Math.ceil(grid*o.myxyplane.zoom_factor);
          //
          //draw gray grids
          //
          ctx.beginPath();
          for (var x=-50; x <= +50; x++) {
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  -50*grid);   
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  +50*grid);   
          }
          for (var y=-50; y <= +50; y++) {
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          ctx.lineWidth = 0.5;
          ctx.stroke();
          //
          // draw both axes
          //
          ctx.beginPath();
          if(1){
            var y = 0;
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(-50*grid,y*grid);
            ctx.moveTo(0,       y*grid);
            ctx.lineTo(+50*grid,y*grid);
          }
          if(1){
            var x = 0;
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  -50*grid);   
            ctx.moveTo(x*grid,  0);
            ctx.lineTo(x*grid,  +50*grid);   
          }
          ctx.lineWidth = 1.0;
          ctx.stroke();
          //
          //black labels
          //
          var fs = o.myfs;
          var text_fs = ""+fs+"px"+" sans-serif";
          ctx.font = text_fs;
          //
          //horizontal labels
          //
          for(var x=-50; x < +50; x++) {
            ctx.fillText(""+x,x*grid,0);
          }
          //
          //vertical labels
          //
          for(var y=-50; y < +50; y++) {
            if(y==0) continue;
            ctx.fillText(""+y,0,-y*grid);
          }
        }
        ///////////////////////////////////////////////
        ///draw plots  
        ///////////////////////////////////////////////
        if(1){
          ctx.strokeStyle = board_curr_color(ctx,canvas);        
          ctx.fillStyle = board_curr_color(ctx,canvas);        
          ctx.lineWidth = board_curr_stroke(ctx,canvas);
          var g = {};
          var r = board_curr_stroke(ctx,canvas);
          var s = o.mytext.trim();
          var x0 = NaN;
          var y0 = NaN;
          var sign0 = NaN;
          for (var h=left; s && h <= right; h++) {
            for (var d=0; d < D; ++d) {
              var xi = h + d/D;
              g['x'] = xi;
              var [yi] = extract_next_expr(s,g,0);
              var sign = Math.sign(yi);
              if(Number.isFinite(xi) && Number.isFinite(yi)){
                ctx.beginPath();
                if(xi==0){
                  //draw y-intercept
                  let pathyi = new Path2D();
                  pathyi.arc(0,-yi*grid,r*2,0,Math.PI*2);
                  o.myxyplane.y_intercepts.push({pathyi,yi});
                  ctx.arc(0,-yi*grid,r*2,0,Math.PI*2);//dot for y-intersect points
                }else{
                  ctx.arc(xi*grid,-yi*grid,r,0,Math.PI*2);//normal points that are not y-intersect point
                }
                ctx.fill();
              }
              if(Number.isFinite(x0) && Number.isFinite(y0) && 
                 Number.isFinite(xi) && Number.isFinite(yi)){
                //draw connecting line
                ctx.beginPath();
                ctx.moveTo(x0*grid,-y0*grid);
                ctx.lineTo(xi*grid,-yi*grid);
                ctx.stroke();
                //draw x-intercept
                if((sign0 < 0 && sign > 0) || (sign0 > 0 && sign < 0 ) || (sign == 0) ){
                  let diff = (0 - y0)/(yi - y0);
                  let xii = (xi - x0)*diff + x0;  
                  if(Number.isFinite(xi)){
                    var pathxi = new Path2D();
                    pathxi.arc(xii*grid,0,r*2,0,Math.PI*2);//only x-intersect points are drawn here
                    ctx.fill(pathxi);
                    o.myxyplane.x_intercepts.push({pathxi,xi:xii});
                  }
                }
              }
              x0 = xi;
              y0 = yi;
              sign0 = sign;
            }
          } 
        }
        ///////////////////////////////////////////////
        ///draw info_tt
        ///////////////////////////////////////////////
        if(o.myxyplane.info_tt){
          let info_tt = o.myxyplane.info_tt;
          let xi = o.myxyplane.info_xi;
          let yi = o.myxyplane.info_yi;
          let fm = ctx.measureText(info_tt);
          let h = fs;
          let tx = 4;
          let ty = -4;
          //ctx.clearRect(tx+xi*grid,ty-yi*grid-fm.fontBoundingBoxAscent,fm.width,fm.fontBoundingBoxDescent+fm.fontBoundingBoxAscent);
          let rect = make_rect(tx+xi*grid,ty-yi*grid-fm.fontBoundingBoxAscent,fm.width,fm.fontBoundingBoxDescent+fm.fontBoundingBoxAscent);
          rect = expand_rect(rect,2);
          //ctx.globalAlpha = 1.0;
          ctx.clearRect(rect.x,rect.y,rect.w,rect.h);
          ctx.fillText(info_tt,tx+xi*grid,ty-yi*grid);
        }
        ctx.globalAlpha = 1.0;
      }
      if(ctx.cake.myop=='ball'){ // ball redraw 
        ctx.resetTransform();
        ctx.clearRect(0,0, canvas.width,canvas.height);
        var corner_size = 4;
        if(o.myaction){
          o.myaction = 0;
          if(o.myball.hitball){
            o.myball.shapeid += 1;
            o.myball.shapeid %= all_shapes.length;
            o.myball.hitball.shapeid = o.myball.shapeid;
            o.myball.hitball.skewX = 0;
            o.myball.hitball.skewY = 0;
            o.myball.hitball.rotation = 0;
          }
        }
        if(o.myball.hitball){
          let ball = o.myball.hitball;
          if(o.myrotation){
            o.myball.hitball.rotation += o.myrotation; 
            o.myrotation = 0; //reset it to zero
          }
          if(o.myflipv){
            o.myflipv = 0;
            let center_p = ball_get_center_p(ball);
            let h = ball.h;
            ball.h = -h;
            ball.skewY = -ball.skewY;
            ball.rotation = 360 - ball.rotation;
          }
          if(o.myfliph){
            o.myfliph = 0;
            let center_p = ball_get_center_p(ball);
            let w = ball.w;
            ball.w = -w;
            ball.skewX = -ball.skewX;
            ball.rotation = 360 - ball.rotation;
          }
        }
        o.myball.balls.forEach((ball,j) => {
          ctx.save();
          let path2d = ball_get_path2d(ball);
          let corners = ball_get_corners(ball);
          let center_p = ball_get_center_p(ball);
          ///transform
          ctx.translate(ball.x,ball.y);
          ctx.rotate(ball.rotation/180*Math.PI);
          ///draw
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = board_get_color(ball.colorid,ctx,canvas);
          ctx.lineWidth = board_get_stroke(ball.strokeid,ctx,canvas);
          ctx.stroke(path2d);
          ///draw corners
          if(o.myball.hitball===ball){
            corners.forEach((pt,i) => {
              let {x,y} = pt;
              ctx.lineWidth = 1;
              ctx.fillStyle = 'yellow';
              ctx.strokeStyle = 'gray';
              if(Number.isFinite(x)&&Number.isFinite(y)){
                ctx.beginPath();
                ctx.arc(x,y,corner_size,0,2*Math.PI,0);
                //ctx.rect(x-corner_size/2,y-corner_size/2,corner_size,corner_size);
                if(i==0){
                  ctx.fillStyle = 'red';
                }else if(i==2){
                  ctx.fillStyle = 'blue';
                }
                ctx.fill();
                ctx.stroke();
              }
            });
          }else if(o.myball.selection.indexOf(ball)>=0){
            corners.forEach((pt,i) => {
              let {x,y} = pt;
              ctx.lineWidth = 1;
              ctx.fillStyle = 'gray';
              ctx.strokeStyle = 'gray';
              if(Number.isFinite(x)&&Number.isFinite(y)){
                ctx.beginPath();
                ctx.arc(x,y,corner_size,0,2*Math.PI,0);
                ctx.fill();
                ctx.stroke();
              }
            });
          }
          ctx.restore();
        });
        ctx.globalAlpha = 1.0;
      }
    }
    function board_action(ctx,canvas){
      var o = ctx.cake;
      o.myaction++; 
    }
    function board_settext(v,ctx,canvas){
      var o = ctx.cake;
      o.mytext = v;
    }
    function board_sethidden(v,ctx,canvas){
      var o = ctx.cake;
      o.hidden = v;
    }
    function board_zoomo(ctx,canvas){
      ///ZOOM_OUT (become smaller)
      let o = ctx.cake;                
      o.myzoom -= 1;
    }
    function board_zoomi(ctx,canvas){
      ///ZOOM_IN (become larger)
      let o = ctx.cake;                
      o.myzoom += 1;
    }
    function board_rotcl(ctx,canvas){
      let o = ctx.cake;                
      o.myrotation += -1;
    }
    function board_rotcr(ctx,canvas){
      let o = ctx.cake;                
      o.myrotation += +1;
    }
    function board_flipv(ctx,canvas){
      let o = ctx.cake;                
      o.myflipv += 1;
    }
    function board_fliph(ctx,canvas){
      let o = ctx.cake;                
      o.myfliph += 1;
    }
    function board_scale(vx,vy,ctx,canvas){
      var o = ctx.cake;
      if(o.myop=='ball'){
        if(o.myball.hitball){
          o.myball.hitball.points.forEach((pt) => {
            //let {op,x,y,cp1x,cp1y,cp2x,cp2y,x1,y1,x2,y2,rx,ry,sAngle,eAngle,anticlockflag} = pt;
            pt.x *= vx;
            pt.y *= vy;
            pt.cp1x *= vx;
            pt.cp1y *= vy;
            pt.cp2x *= vx;
            pt.cp2y *= vy;
            pt.x1 *= vx;
            pt.y1 *= vy;
            pt.x2 *= vx;
            pt.y2 *= vy;
            pt.rx *= vx;
            pt.ry *= vy;
          });
          o.myball.hitball.w *= vx;
          o.myball.hitball.h *= vy;
        }
      }
    }
    function board_rotate(v,ctx,canvas){//v is in DEGREES
      let o = ctx.cake;
      if(o.myop=='ball'){
        if(o.myball.hitball){
          let cos = Math.cos(v/180*Math.PI);
          let sin = Math.sin(v/180*Math.PI);
          o.myball.hitball.points.forEach((pt) => {
            //let {op,x,y,cp1x,cp1y,cp2x,cp2y,x1,y1,x2,y2,rx,ry,sAngle,eAngle,anticlockflag} = pt;
            [pt.x,    pt.y]       = RotatePoint(pt.x,    pt.y,    cos,sin);
            [pt.cp1x, pt.cp1y]    = RotatePoint(pt.cp1x, pt.cp1y, cos,sin);
            [pt.cp2x, pt.cp2y]    = RotatePoint(pt.cp2x, pt.cp2y, cos,sin);
            [pt.x1,   pt.y1]      = RotatePoint(pt.x1,   pt.y1,   cos,sin);
            [pt.x2,   pt.y2]      = RotatePoint(pt.x2,   pt.y2,   cos,sin);
          });
        }
      }
    }
    function RotatePoint(x,y,cos,sin){ //v is in degrees
      let x1 = (x)*(cos) - (y)*(sin);
      let y1 = (x)*(sin) + (y)*(cos);
      return [x1,y1];
    }
    function polypts_add_xy(x,y, polypts){
      ///check for duplicates
      var dup_flag = 0;
      for(let i=0; i < polypts.length; ++i){
        if(polypts[i].x == x && polypts[i].y == y){
          dup_flag = 1;
          break;
        }
      } 
      if(!dup_flag){
        var mypt = {x,y};
        polypts.push(mypt);
      }
    }
    function polypts_find_xy(sx,sy, polypts){
      var dist = Infinity;
      var tx = 0;
      var ty = 0;
      var n = 0;
      for(let i=0; i < polypts.length; ++i){
        let {x,y} = polypts[i];
        var d = (x-sx)*(x-sx) + (y-sy)*(y-sy);
        if(d <= 144){
          if(n){
            if(d < dist){
              tx = x;
              ty = y;
              dist = d;
            }
          }else{
            tx = x;
            ty = y;
            dist = d;
            n++;
          }
        }
      }
      if(n){
        return [tx,ty];
      }else{
        return [sx,sy];
      }
    }
    function board_cutbd(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        ctx.resetTransform();
        if(o.mybasis.s){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.s,0,0);
        }
        if(o.mybasis.face){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.face,0,0);
        }
        let {x,y,w,h} = o.mybasis;
        if(w && h){
          o.mybasis.clipboard = ctx.getImageData(x,y, w,h);                       
          ctx.clearRect(x,y, w,h);
          o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
        }
      }
      if(o.myop=='ball'){
        ctx.resetTransform();
        if(o.myball.hitball){
          let ball = o.myball.hitball;
          let i = o.myball.balls.indexOf(ball);
          if(i >= 0){
            o.myball.balls.splice(i,1);
            o.myball.clipball = {...o.myball.hitball};
            o.myball.hitball = null;
          }
        }
      }
    }
    function board_paste(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        ctx.resetTransform();
        if(o.mybasis.face){
          o.mybasis.s = o.mybasis.face;
        }
      }
      if(o.myop=='ball'){
        ctx.resetTransform();
        if(o.myball.clipball){
          let ball = o.myball.clipball;
          ball = {...ball};
          o.myball.hitball = ball;
          o.myball.balls.push(ball);
        }
      }
    }
    function board_rsize(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        o.mybasis.rsize += 1;
        o.mybasis.rsize %= 2;
      }
    }
    function board_copy(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        ctx.resetTransform();
        ctx.clearRect(0,0, canvas.width,canvas.height);
        if(o.mybasis.s){
          ctx.putImageData(o.mybasis.s,0,0);
        }
        let {x,y,w,h} = o.mybasis;
        if(w && h){
          o.mybasis.clipboard = ctx.getImageData(x,y, w,h);                       
        }
      }
    }
    function board_fg2bg(ctx,canvas){
      var o = ctx.cake;          
      let data_s = canvas.toDataURL();
      canvas.style.backgroundImage = "url("+data_s+")";
    }
    function board_bg2fg(ctx,canvas){
      var o = ctx.cake;          
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function(){
        o.mybasis.clipboard = null;
        o.mybasis.s = null;
        o.mybasis.x = 0;
        o.mybasis.y = 0;
        o.mybasis.w = 0;
        o.mybasis.h = 0;
        ctx.clearRect(0,0, canvas.width,canvas.height);
        ctx.drawImage(img, 0,0,parseInt(canvas.width),parseInt(canvas.height));
        canvas.style.backgroundImage = '';
      }
      let boardpng = canvas.getAttribute('data-boardpng');
      img.src = boardpng;
    }
    function board_clear(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        ctx.resetTransform();
        if(o.mybasis.s){
          ctx.putImageData(o.mybasis.s,0,0);
        }
        let {x,y,w,h} = o.mybasis;
        if(w && h){
          ctx.clearRect(x,y, w,h);
          o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
        }
        o.mybasis.clipboard = null;
      }else{
        ctx.resetTransform();
        ctx.clearRect(0,0, canvas.width,canvas.height);
      }
    }
    function board_cropp(ctx,canvas){
      var o = ctx.cake;          
      if(o.myop=='select'){
        ctx.resetTransform();
        if(o.mybasis.s){
          ctx.clearRect(0,0, canvas.width,canvas.height);
          ctx.putImageData(o.mybasis.s,0,0);
        }
        let {x,y,w,h} = o.mybasis;
        if(w && h){
          let idata = ctx.getImageData(x,y, w,h);
          ctx.clearRect(0,0, canvas.width,canvas.height);
          o.mybasis.s = ctx.getImageData(0,0, canvas.width,canvas.height);
          o.mybasis.clipboard = idata;
        }
      }
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function board_onmousedown(){
      var evt = event;
      var canvas = evt.target;
      var ctx = canvas.getContext("2d");
      board_assert(ctx,canvas);
      if(evt.button==0){
        let [sx,sy] = board_calc_sx_and_sy(canvas);
        ctx.cake.posx0 = Math.round((evt.clientX-canvas.getBoundingClientRect().x)*sx);
        ctx.cake.posy0 = Math.round((evt.clientY-canvas.getBoundingClientRect().y)*sy);
        ctx.cake.posx1 = ctx.cake.posx0;
        ctx.cake.posy1 = ctx.cake.posy0;
        ctx.cake.posx2 = ctx.cake.posx1;
        ctx.cake.posy2 = ctx.cake.posy1;
        ctx.cake.shiftKey = evt.shiftKey;
        ctx.cake.altKey   = evt.altKey;
        ctx.cake.mouseisdown = 1;
        ctx.cake.mouseisdragged = 0;
        ctx.cake.mousedragcount = 0;
        board_start(ctx,canvas);
      }
    }
    function board_onmousemove(){
      var evt = event;
      var canvas = evt.target;
      var ctx = canvas.getContext("2d");
      board_assert(ctx,canvas);
      if(evt.button==0){
        let [sx,sy] = board_calc_sx_and_sy(canvas);
        ctx.cake.posx1 = ctx.cake.posx2;
        ctx.cake.posy1 = ctx.cake.posy2;
        ctx.cake.posx2 = Math.round((evt.clientX-canvas.getBoundingClientRect().x)*sx);
        ctx.cake.posy2 = Math.round((evt.clientY-canvas.getBoundingClientRect().y)*sy);
        ctx.cake.shiftKey = evt.shiftKey;
        ctx.cake.altKey   = evt.altKey;
        if(ctx.cake.mouseisdown){
          board_drag(ctx,canvas);
          ctx.cake.mouseisdragged = 1;
          ctx.cake.mousedragcount += 1;
        }else{
          board_hover(ctx,canvas);
        }
      }
    }
    function board_onmouseup(){
      var evt = event;
      var canvas = evt.target;
      var ctx = canvas.getContext("2d");
      board_assert(ctx,canvas);
      if(evt.button==0){
        if(ctx.cake.mouseisdown){
          board_end(ctx,canvas);
          ctx.cake.mouseisdragged = 0;
          ctx.cake.mousedragcount = 0;
        }
        ctx.cake.mouseisdown = 0;
        ctx.cake.shiftKey = 0;
        ctx.cake.altKey = 0;
      }
    }
    function board_onmouseenter(){
      var evt = event;
      var canvas = evt.target;
      var ctx = canvas.getContext("2d");
      board_assert(ctx,canvas);
      if(ctx.cake.mouseisdown){
        board_end(ctx,canvas);
        ctx.cake.mouseisdragged = 0;
        ctx.cake.mousedragcount = 0;
      }
      ctx.cake.mouseisdown = 0;
      ctx.cake.shiftKey = evt.shiftKey;
      ctx.cake.altKey   = evt.altKey;
    }
    function board_onmouseleave(){
      var evt = event;
      var canvas = evt.target;
      var ctx = canvas.getContext("2d");
      board_assert(ctx,canvas);
      if(ctx.cake.mouseisdown){
        board_end(ctx,canvas);
        ctx.cake.mouseisdragged = 0;
        ctx.cake.mousedragcount = 0;
      }
      ctx.cake.mouseisdown = 0;
      ctx.cake.shiftKey = evt.shiftKey;
      ctx.cake.altKey   = evt.altKey;
    }
    function board_ontouchstart() {
      var evt = event;
      evt.preventDefault();
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        var touch = touches[i];
        var canvas = touch.target;                             
        var ctx = canvas.getContext("2d");
        board_assert(ctx,canvas);
        let [sx,sy] = board_calc_sx_and_sy(canvas);
        ctx.cake.posx0 = Math.round((touch.clientX-canvas.getBoundingClientRect().x)*sx);
        ctx.cake.posy0 = Math.round((touch.clientY-canvas.getBoundingClientRect().y)*sy);
        ctx.cake.posx1 = ctx.cake.posx0;
        ctx.cake.posy1 = ctx.cake.posy0;
        ctx.cake.posx2 = ctx.cake.posx1;
        ctx.cake.posy2 = ctx.cake.posy1;
        ctx.cake.mouseisdown = 1;
        ctx.cake.shiftKey = evt.shiftKey;
        ctx.cake.altKey   = evt.altKey;
        if(ctx.cake.mouseisdown){
          ctx.cake.mouseisdragged = 0;
          ctx.cake.mousedragcount = 0;
          board_start(ctx,canvas);
        }
      }
    }
    function board_ontouchmove() {
      var evt = event;
      evt.preventDefault();
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        var touch = touches[i];
        var canvas = touch.target;                            
        var ctx = canvas.getContext("2d");
        board_assert(ctx,canvas);
        let [sx,sy] = board_calc_sx_and_sy(canvas);
        ctx.cake.posx1 = ctx.cake.posx2;
        ctx.cake.posy1 = ctx.cake.posy2;
        ctx.cake.posx2 = Math.round((touch.clientX-canvas.getBoundingClientRect().x)*sx);
        ctx.cake.posy2 = Math.round((touch.clientY-canvas.getBoundingClientRect().y)*sy);
        ctx.cake.shiftKey = evt.shiftKey;
        ctx.cake.altKey   = evt.altKey;
        if(ctx.cake.mouseisdown){
          board_drag(ctx,canvas);
          ctx.cake.mouseisdragged = 1;
          ctx.cake.mousedragcount += 1;
        }else{
          board_hover(ctx,canvas);
        }
      }
    }
    function board_ontouchend() {
      var evt = event;
      evt.preventDefault();
      var touches = evt.changedTouches;
      for (var i = 0; i < touches.length; i++) {
        var touch = touches[i];
        var canvas = touch.target;                            
        var ctx = canvas.getContext("2d");
        board_assert(ctx,canvas);
        if(ctx.cake.mouseisdown){
          board_end(ctx,canvas);
          ctx.cake.mouseisdragged = 0;
          ctx.cake.mousedragcount = 0;
        }
        ctx.cake.mouseisdown = 0;
        ctx.cake.shiftKey = 0;
        ctx.cake.altKey   = 0;
      }
    }
    function board_ontouchcancel(evt) {
      evt.preventDefault();
      for (var i = 0; i < touches.length; i++) {
        var touch = touches[i];
        var canvas = touch.target;                            
        var ctx = canvas.getContext("2d");
        board_assert(ctx,canvas);
        if(ctx.cake.mouseisdown){
          board_end(ctx,canvas);
          ctx.cake.mouseisdragged = 0;
          ctx.cake.mousedragcount = 0;
        }
        ctx.cake.mouseisdown = 0;
        ctx.cake.shiftKey = 0;
        ctx.cake.altKey   = 0;
      }
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function erase_between(posx0,posy0,posx,posy,lw,ctx){
      let dx = posx-posx0;
      let dy = posy-posy0;
      let Dx = Math.abs(dx);
      let Dy = Math.abs(dy);
      if(Dx==0&&Dy==0){
        var n = 1;
      }else if((Dx)>(Dy)){
        var n = Math.ceil(Dx/lw);
      }else{
        var n = Math.ceil(Dy/lw);
      }
      n = Math.max(1,n);
      dx /= n;
      dy /= n;
      for(i=0; i <= n; ++i){
        let x = posx0 + dx*i;
        let y = posy0 + dy*i;
        ctx.clearRect(x-(lw/2),y-(lw/2),lw,lw);
      }
    }
    function pencil_between(posx0,posy0,posx,posy,lw,ctx){
      lw = Math.max(1,lw);
      let dx = posx-posx0;
      let dy = posy-posy0;
      let Dx = Math.abs(dx);
      let Dy = Math.abs(dy);
      if(Dx==0&&Dy==0){
        var n = 1;
      }else if((Dx)>(Dy)){
        var n = Math.ceil(Dx/lw);
      }else{
        var n = Math.ceil(Dy/lw);
      }
      n = Math.max(1,n);
      dx /= n;
      dy /= n;
      for(i=0; i <= n; ++i){
        let x = posx0 + dx*i;
        let y = posy0 + dy*i;
        ctx.fillRect(x-(lw/2),y-(lw/2),lw,lw);
      }
    }
    function smudge_fill(x,y,stacksize,n,sx,sy,dir,mysmear,ctx,canvas){
      x = Math.floor(x);
      y = Math.floor(y);
      if(stacksize<500 && n < 10000){
        var count = smudgeRect(x,y,1,1,mysmear,0,ctx,canvas);
        n += count;
        if(count){
          let dy = y-sy;
          let dx = x-sx;
          if(dy >= 0 && dx >= 0){
            if(Math.abs(dy) > Math.abs(dx)){
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }else{
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }
          }else if(dy >= 0){
            if(Math.abs(dy) > Math.abs(dx)){
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }else{
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }
          }else if(dx >= 0){
            if(Math.abs(dy) > Math.abs(dx)){
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }else{
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }
          }else{ 
            if(Math.abs(dy) > Math.abs(dx)){
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }else{
              n = smudge_fill(x-1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y-1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x,  y+1,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
              n = smudge_fill(x+1,y  ,stacksize+1,n,sx,sy,dir+1,mysmear,ctx,canvas);
            }
          }
        }
      } 
      return n;
    }
    function smudge_between(posx0,posy0,posx,posy,lw,mysmear,clearflag,ctx,canvas){
      let dx = posx-posx0;
      let dy = posy-posy0;
      let Dx = Math.abs(dx);
      let Dy = Math.abs(dy);
      if(Dx==0&&Dy==0){
        var n = 1;
      }else if((Dx)>(Dy)){
        var n = Math.ceil(Dx/lw);
      }else{
        var n = Math.ceil(Dy/lw);
      }
      n = Math.max(1,n);
      dx /= n;
      dy /= n;
      for(i=0; i <= n; ++i){
        let x = posx0 + dx*i;
        let y = posy0 + dy*i;
        smudgeRect(x-(lw/2),y-(lw/2),lw,lw,mysmear,clearflag,ctx,canvas);
      }
    }
    function smudgeRect(x,y,w,h,mysmear,clearflag,ctx,canvas){
      ///RETURN the total number of pixels colored
      var count = 0;
      if(w && h){
        if(w < 0){
          x += w;
          w = -w;
        }
        if(h < 0){
          y += h;
          h = -h;
        }
        var width = canvas.width;
        var height = canvas.height;
        if(x >= 0 && y >= 0 && x < width && y < height){
          var idata = ctx.getImageData(x,y,w,h);
          const cutoff = 64;
          for(let i=0; i < idata.data.length; i+=4){
            if(idata.data[i+3]<=cutoff){
              if(clearflag){
                idata.data[i+0] = 0;
                idata.data[i+1] = 0;
                idata.data[i+2] = 0;
                idata.data[i+3] = 0;
              }else{
                var rand1 = 0.5+Math.random()*0.5;
                var rand2 = 0.5+Math.random()*0.5;
                idata.data[i+0] = mysmear[0];
                idata.data[i+1] = mysmear[1];
                idata.data[i+2] = mysmear[2];
                idata.data[i+3] = rand2*cutoff;
                count++;
              }
            }
          }
          ctx.putImageData(idata,x,y);
        }
      }
      return count;
    }
    function normalizeRect(x,y,w,h){
      if(w < 0){
        x = x + w;
        w = -w;
      }
      if(h < 0){
        y = y + h;
        h = -h;
      }
      return [x,y,w,h];
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function board_draw_smudge(x1,y1,x2,y2,clearflag,ctx,canvas){
      let stroke = board_curr_stroke(ctx,canvas);
      let color = board_curr_color(ctx,canvas);        
      let mysmear = all_smears[color];
      var lw = 3*stroke;
      lw = Math.max(lw,1);
      smudge_between(x1,y1,x2,y2,lw,mysmear,clearflag,ctx,canvas);
    }
    function board_drag_smudge(x1,y1,x2,y2,clearflag,ctx,canvas){
      let stroke= board_curr_stroke(ctx,canvas);
      let color = board_curr_color(ctx,canvas);        
      let mysmear = all_smears[color];
      smudgeRect(x1,y1,x2-x1,y2-y1,mysmear,clearflag,ctx,canvas);
    }
    function board_smudge_fill(x,y,ctx,canvas){
      let stroke= board_curr_stroke(ctx,canvas);
      let color = board_curr_color(ctx,canvas);        
      let mysmear = all_smears[color];
      smudge_fill(x,y,0,0,x,y,0,mysmear,ctx,canvas);
    }
    function board_draw_clear(ctx,canvas,first){
      ctx.clearRect(0,0,canvas.getAttribute('width'),canvas.getAttribute('height'));
    }
    function board_draw_pencil(x1,y1,x2,y2,ctx,canvas){
      ctx.lineWidth = board_curr_stroke(ctx,canvas);
      ctx.strokeStyle = board_curr_color(ctx,canvas);           
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }
    function board_drag_pencil(x,y,x2,y2,ctx,canvas){
      ctx.strokeStyle = board_curr_color(ctx,canvas);           
      ctx.fillRect(x,y,x2-x,y2-y);
    }
    function board_draw_eraser(x1,y1,x2,y2,ctx,canvas){
      let stroke= board_curr_stroke(ctx,canvas);
      var lw = 3*stroke;
      var lw = Math.round(lw);//this is to work around the bug of Edge V93 on mac (number less than 1 will cause an error of "width is 0")
      erase_between(x1,y1,x2,y2,lw,ctx);
    }
    function board_drag_eraser(x,y,x2,y2,ctx,canvas){
      ctx.clearRect(x,y,x2-x,y2-y);
    }
    function board_calc_sx_and_sy(canvas){
      let sx = canvas.getAttribute("width")/canvas.getBoundingClientRect().width;
      let sy = canvas.getAttribute("height")/canvas.getBoundingClientRect().height;
      return [sx,sy];
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function board_start(ctx,canvas){
      ///
      ///console.log('board_start','op=',ctx.cake.myop,'id=',canvas.id,'altKey=',ctx.cake.altKey,'shiftKey=',ctx.cake.shiftKey);
      ///
      let o = ctx.cake;
      if(ctx.cake.myop=='select'){ //board_start select
        o.mybasis.shiftKey = ctx.cake.shiftKey;
        o.mybasis.altKey = ctx.cake.altKey;
        let px = ctx.cake.posx0;
        let py = ctx.cake.posy0;
        let {x,y,w,h} = o.mybasis;
        o.mybasis.isinside = IsPointInRect(px,py, x,y,w,h);
        let {altKey,shiftKey,isinside} = o.mybasis;
        if(altKey && shiftKey){
          if(o.mybasis.face){
            o.mybasis.s = o.mybasis.face;
          }
          o.mybasis.istomove = 1;
          o.mybasis.istosize = 0;
        }else if(altKey){
          o.mybasis.istomove = 1;
          o.mybasis.istosize = 0;
        }else if(isinside){
          o.mybasis.istomove = 1;
          o.mybasis.istosize = 0;
        }else{
          if(o.mybasis.face){
            o.mybasis.s = o.mybasis.face;
            o.mybasis.clipboard = null;
          }
          o.mybasis.istomove = 0;
          o.mybasis.istosize = 1;
          o.mybasis.x = px;
          o.mybasis.y = py;
          o.mybasis.w = 0;
          o.mybasis.h = 0;
          o.mybasis.isnewselection = 1;
        }
        o.mybasis.x0 = o.mybasis.x;
        o.mybasis.y0 = o.mybasis.y;
        o.mybasis.w0 = o.mybasis.w;
        o.mybasis.h0 = o.mybasis.h;
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='pencil'){ // pencil start      
        o.mypencil.shiftKey = ctx.cake.shiftKey;
        o.mypencil.altKey = ctx.cake.altKey;
        o.mypencil.x = ctx.cake.posx0;
        o.mypencil.y = ctx.cake.posy0;
        o.mypencil.x1 = ctx.cake.posx0;
        o.mypencil.y1 = ctx.cake.posy0;
        o.mypencil.x2 = ctx.cake.posx0;
        o.mypencil.y2 = ctx.cake.posy0;
        o.mypencil.w = 0;
        o.mypencil.h = 0;
        let {altKey,shiftKey,x,y,x1,y1,x2,y2,w,h} = o.mypencil;
        if(altKey){
          if(shiftKey){
            board_drag_eraser(x,y,x2,y2,ctx,canvas);
          }else{
            board_drag_pencil(x,y,x2,y2,ctx,canvas);
          }
        }else{
          if(shiftKey){
            board_draw_eraser(x1,y1,x2,y2,ctx,canvas);
          }else{
            board_draw_pencil(x1,y1,x2,y2,ctx,canvas);
          }
        }
      }
      if(o.myop=='smudge'){ // smudge start
        o.mysmudge.shiftKey = ctx.cake.shiftKey;
        o.mysmudge.altKey = ctx.cake.altKey;
        o.mysmudge.x = ctx.cake.posx0;
        o.mysmudge.y = ctx.cake.posy0;
        o.mysmudge.x1 = ctx.cake.posx0;
        o.mysmudge.y1 = ctx.cake.posy0;
        o.mysmudge.x2 = ctx.cake.posx0;
        o.mysmudge.y2 = ctx.cake.posy0;
        o.mysmudge.w = 0;
        o.mysmudge.h = 0;
        let {x,y,x1,y1,x2,y2,w,h} = o.mysmudge;
        if(ctx.cake.altKey){
          if(ctx.cake.shiftKey){
            board_drag_smudge(x,y,x2,y2, 1, ctx,canvas);
          }else{
            board_drag_smudge(x,y,x2,y2, 0, ctx,canvas);
          }
        }else{
          if(ctx.cake.shiftKey){
            board_draw_smudge(x1,y1,x2,y2, 1, ctx,canvas);
          }else{
            board_draw_smudge(x1,y1,x2,y2, 0, ctx,canvas);
          }
        }
      }
      if(o.myop=='eraser'){ // eraser start
        o.myeraser.x = ctx.cake.posx0;
        o.myeraser.y = ctx.cake.posy0;
        o.myeraser.x1 = ctx.cake.posx0;
        o.myeraser.y1 = ctx.cake.posy0;
        o.myeraser.x2 = ctx.cake.posx0;
        o.myeraser.y2 = ctx.cake.posy0;
      }
      if(ctx.cake.myop=='poly'   // poly start      
        || ctx.cake.myop=='rect'   // poly start      
        || ctx.cake.myop=='elli'){ // poly start      
        o.mypoly.shiftKey = ctx.cake.shiftKey;
        o.mypoly.altKey = ctx.cake.altKey;
        o.mypoly.s = ctx.getImageData(0,0, canvas.width,canvas.height);
        o.mypoly.x = ctx.cake.posx0;
        o.mypoly.y = ctx.cake.posy0;
        o.mypoly.x1 = ctx.cake.posx0;
        o.mypoly.y1 = ctx.cake.posy0;
        o.mypoly.x2 = ctx.cake.posx0;
        o.mypoly.y2 = ctx.cake.posy0;
        o.mypoly.w = 0;
        o.mypoly.h = 0;
        let {x,y} = o.mypoly;
        if(!ctx.cake.altKey){
          [x,y] = polypts_find_xy(x,y, o.mypoly.polypts);
          o.mypoly.x = x;
          o.mypoly.y = y;
        }
      }
      if(ctx.cake.myop=='cplane'){ //board_start cplane
        ///check to see if mouse click is directly on top of the handle dot
        o.mycplane.pointisinhandle = false;
        ctx.save();
        let reduce_rate = 1;
        if(o.mycplane.scale_factor > 1){
          reduce_rate = Math.log(o.mycplane.scale_factor)+1;
        }
        ctx.lineWidth=10*(1/reduce_rate); 
        if(o.mycplane.path_handle){
          if(ctx.isPointInPath(o.mycplane.path_handle, ctx.cake.posx0,ctx.cake.posy0)){ 
            o.mycplane.pointisinhandle = true;
          }else if(ctx.isPointInStroke(o.mycplane.path_handle, ctx.cake.posx0,ctx.cake.posy0)){ 
            o.mycplane.pointisinhandle = true;
          }
        }
        //console.log('pointisinhandle',o.mycplane.pointisinhandle);
        ctx.restore();
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='xyplane'){ //board_start xyplane
        let x = ctx.cake.posx2;
        let y = ctx.cake.posy2;
        ///////////////////////////////
        ///need to rebuild info_tt for each mouse click
        ///////////////////////////////
        o.myxyplane.info_tt = '';
        for(let j=0; j < o.myxyplane.y_intercepts.length; ++j){
          let p = o.myxyplane.y_intercepts[j];
          ctx.lineWidth=10;
          if(ctx.isPointInStroke(p.pathyi,x,y)){
            //console.log('yi=',p.yi);
            o.myxyplane.info_tt = ""+p.yi;
            o.myxyplane.info_xi = 0;
            o.myxyplane.info_yi = p.yi;
          } 
        }
        for(let j=0; j < o.myxyplane.x_intercepts.length; ++j){
          let p = o.myxyplane.x_intercepts[j];
          ctx.lineWidth=10;
          if(ctx.isPointInStroke(p.pathxi,x,y)){
            //console.log('xi=',p.xi);
            o.myxyplane.info_tt = ""+p.xi;
            o.myxyplane.info_xi = p.xi;
            o.myxyplane.info_yi = 0;
          } 
        }
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='ball'){ //board_start ball
        o.myball.altKey = ctx.cake.altKey;
        o.myball.shiftKey = ctx.cake.shiftKey;
        let {altKey,shiftKey} = o.myball;
        if(altKey && shiftKey){
          if(o.myball.hitball){
            let ball = o.myball.hitball;
            ball = {...ball};
            o.myball.balls.push(ball);
            o.myball.hitball = ball;
            o.myball.hitball.corner_i = -1;
            o.myball.istodo = 'move';
            ball.x0 = ball.x;
            ball.y0 = ball.y;
          }else{
            //create new ball                                     
            let ball = ball_new_ball(o.myshapeid,o.mycolorid,o.mystrokeid,ctx.cake.posx0,ctx.cake.posy0);
            o.myball.balls.push(ball);
            o.myball.hitball = ball;//making it the latest hit ball
            o.myball.hitball.corner_i = -1;
            o.myball.istodo = 'move';
            ball.x0 = ball.x;
            ball.y0 = ball.y;
          }
        }else if(altKey){
          //select balls
          o.myball.istodo = 'select';
          o.myball.x = ctx.cake.posx0;
          o.myball.y = ctx.cake.posy0;
          o.myball.w = 0;
          o.myball.h = 0;
        }else{
          let old_hitball = o.myball.hitball;
          if(o.myball.hitball){
            o.myball.hitball.corner_i = ball_find_hitcorner(ctx.cake.posx0,ctx.cake.posy0, o.myball.hitball,ctx);
          }
          if(!o.myball.hitball || o.myball.hitball.corner_i < 0){
            o.myball.hitball = ball_find_hitball(ctx.cake.posx0,ctx.cake.posy0, o.myball.balls,ctx);
            if(o.myball.hitball){
              let ball = o.myball.hitball;
              o.myball.hitball.corner_i = ball_find_hitcorner(ctx.cake.posx0,ctx.cake.posy0, o.myball.hitball,ctx);
              if(o.myball.hitball.corner_i==0){
                o.myball.istodo = '';  //rotate next time
              }else if(o.myball.hitball.corner_i==-1){
                o.myball.istodo = 'move';  
                ball.x0 = ball.x;
                ball.y0 = ball.y;
              }
            }
          }
          if(old_hitball !== o.myball.hitball){
            o.myball.istodo = '';
          }else if(o.myball.hitball){
            let ball = o.myball.hitball;
            if(o.myball.hitball.corner_i==0){
              o.myball.istodo = 'move';  
              ball.x0 = ball.x;
              ball.y0 = ball.y;
            }else if(o.myball.hitball.corner_i==2){
              o.myball.istodo = 'size';  
            }else if(o.myball.hitball.corner_i==1){
              o.myball.istodo = 'skewY';  
            }else if(o.myball.hitball.corner_i==3){
              o.myball.istodo = 'skewX';  
            }
          }else{
            o.myball.istodo = 'create';
            o.myball.iscreateflag = 1;
          }
        }
        board_redraw(ctx,canvas);
      }
    }
    function board_hover(ctx,canvas){
      //EMPTY
    }
    function board_drag(ctx,canvas){
      let o = ctx.cake;                
      if(ctx.cake.myop=='select'){ //board_drag select
        let {altKey,shiftKey,rsize,istomove,istosize} = o.mybasis;
        if(rsize==1){
          let dx = ctx.cake.posx2 - ctx.cake.posx1;
          let dy = ctx.cake.posy2 - ctx.cake.posy1;
          o.mybasis.w += dx;
          o.mybasis.h += dy;
        }else if(istomove){
          let dx = ctx.cake.posx2 - ctx.cake.posx0;
          let dy = ctx.cake.posy2 - ctx.cake.posy0;
          if(ctx.cake.shiftKey){
            if(Math.abs(dx) <= 2 && Math.abs(dy) <= 2){
              dx = 0;   
              dy = 0;
            }else if(Math.abs(dx) > Math.abs(dy)){
              dy = 0;
            }else{
              dx = 0;
            }
          }
          o.mybasis.x = o.mybasis.x0 + dx;
          o.mybasis.y = o.mybasis.y0 + dy;
        }else if(istosize){
          let dx = ctx.cake.posx2 - ctx.cake.posx0;
          let dy = ctx.cake.posy2 - ctx.cake.posy0;
          if(o.mybasis.isnewselection){
            if(Math.abs(dx) > 10 || Math.abs(dy) > 10){
              o.mybasis.isnewselection = 0;
            }else{
              dx = 0;
              dy = 0;
            }
          }
          if(ctx.cake.shiftKey){
            if(Math.abs(dx) <= 2 && Math.abs(dy) <= 2){
              dx = 0;   
              dy = 0;
            }else if(Math.abs(dx) > Math.abs(dy)){
              dy = 0;
            }else{
              dx = 0;
            }
          }
          o.mybasis.w = o.mybasis.w0 + dx;
          o.mybasis.h = o.mybasis.h0 + dy;
        }
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='pencil'){ // pencil drag
        o.mypencil.w = ctx.cake.posx2 - o.mypencil.x;
        o.mypencil.h = ctx.cake.posy2 - o.mypencil.y;
        o.mypencil.x1 = ctx.cake.posx1;
        o.mypencil.y1 = ctx.cake.posy1;
        o.mypencil.x2 = ctx.cake.posx2;
        o.mypencil.y2 = ctx.cake.posy2;
        let {altKey,shiftKey,x,y,x1,y1,x2,y2} = o.mypencil;
        if(altKey){
          if(shiftKey){
            board_drag_eraser(x,y,x2,y2,ctx,canvas);
          }else{
            board_drag_pencil(x,y,x2,y2,ctx,canvas);
          }
        } else {
          if(shiftKey){
            board_draw_eraser(x1,y1,x2,y2,ctx,canvas);
          }else{
            board_draw_pencil(x1,y1,x2,y2,ctx,canvas);
          }
        }
      }
      if(o.myop=='poly'   // poly drag
        || o.myop=='rect'   // poly drag
        || o.myop=='elli'){ // poly drag
        o.mypoly.w = ctx.cake.posx2 - o.mypoly.x;
        o.mypoly.h = ctx.cake.posy2 - o.mypoly.y;
        o.mypoly.x1 = ctx.cake.posx1;
        o.mypoly.y1 = ctx.cake.posy1;
        o.mypoly.x2 = ctx.cake.posx2;
        o.mypoly.y2 = ctx.cake.posy2;
        let {x,y,x1,y1,x2,y2,s} = o.mypoly;
        if(s){
          ctx.putImageData(s, 0,0);
        }
        if(!ctx.cake.altKey){
          [x2,y2] = polypts_find_xy(x2,y2, o.mypoly.polypts);
          o.mypoly.x2 = x2;
          o.mypoly.y2 = y2;
        }
        let dx = x2-x;
        let dy = y2-y;
        if(ctx.cake.shiftKey){
          if(Math.abs(dx) > Math.abs(dy)){
            dy = 0;
            y2 = y;
            o.mypoly.y2 = y2;
          }else{
            dx = 0;
            x2 = x;
            o.mypoly.x2 = x2;
          }
        }
        ctx.save();
        ctx.lineWidth   = board_curr_stroke(ctx,canvas);
        ctx.strokeStyle = board_curr_color(ctx,canvas);
        ctx.translate(x,y);
        let path2d = poly_get_path2d(o.myop,x2-x,y2-y);
        ctx.stroke(path2d);
        ctx.restore();
      }
      if(o.myop=='smudge'){ // smudge drag
        o.mysmudge.w = ctx.cake.posx2 - o.mysmudge.x;
        o.mysmudge.h = ctx.cake.posy2 - o.mysmudge.y;
        o.mysmudge.x1 = ctx.cake.posx1;
        o.mysmudge.y1 = ctx.cake.posy1;
        o.mysmudge.x2 = ctx.cake.posx2;
        o.mysmudge.y2 = ctx.cake.posy2;
        if(ctx.cake.altKey){
          let stroke = board_curr_stroke(ctx,canvas);
          let color = board_curr_color(ctx,canvas);        
          let mysmear = all_smears[color];
          let {x,y,x2,y2} = ctx.cake.mysmudge;
          if(ctx.cake.shiftKey){
            board_drag_smudge(x,y,x2,y2, 1, ctx,canvas);
          }else{
            board_drag_smudge(x,y,x2,y2, 0, ctx,canvas);
          }
        }else{
          let {x1,y1,x2,y2} = ctx.cake.mysmudge;
          if(ctx.cake.shiftKey){
            board_draw_smudge(x1,y1,x2,y2, 1, ctx,canvas);
          }else{
            board_draw_smudge(x1,y1,x2,y2, 0, ctx,canvas);
          }
        }
      }
      if(o.myop=='eraser'){ // eraser drag
        o.myeraser.w = ctx.cake.posx2 - o.myeraser.x;
        o.myeraser.h = ctx.cake.posy2 - o.myeraser.y;
        o.myeraser.x1 = ctx.cake.posx1;
        o.myeraser.y1 = ctx.cake.posy1;
        o.myeraser.x2 = ctx.cake.posx2;
        o.myeraser.y2 = ctx.cake.posy2;
        let {x1,y1,x2,y2} = o.myeraser;
        board_draw_eraser(x1,y1,x2,y2, ctx,canvas);
      }
      if(ctx.cake.myop=='cplane'){ //board_drag cplane
        let grid = o.mycplane.grid;
        if(o.mycplane.pointisinhandle){
          o.mycplane.ishandledragged = 1;
          let diff_x = ctx.cake.posx2 - o.mycplane.origin_x;
          let diff_y = ctx.cake.posy2 - o.mycplane.origin_y;
          diff_x /= o.mycplane.zoom_factor;
          diff_y /= o.mycplane.zoom_factor;
          if(ctx.cake.altKey){
            let dx = Math.round(diff_x);
            let dy = Math.round(diff_y);
            dx %= grid;
            dy %= grid;
            if(dx < 0) dx += grid;
            if(dy < 0) dy += grid;
            let snap_dist = 5;//snaptogrid within 10px
            let r = Math.sqrt(diff_x*diff_x+diff_y*diff_y);
            if( (!o.mycplane.snap_type) && (dy<=snap_dist||(grid-dy)<=snap_dist) && (dx<=snap_dist||(grid-dx)<=snap_dist) ){
              o.mycplane.snap_type = 'point';
            }
            if( (!o.mycplane.snap_type) && (Math.abs(r-grid)<=snap_dist) ){
              o.mycplane.snap_type = 'circle';
            }
            if( (!o.mycplane.snap_type) && (dx<=snap_dist||(grid-dx)<=snap_dist) ){
              o.mycplane.snap_type = 'vline';
            }
            if( (!o.mycplane.snap_type) && (dy<=snap_dist||(grid-dy)<=snap_dist) ){
              o.mycplane.snap_type = 'hline';
            }
            if(o.mycplane.snap_type=='circle'){
              let rate = r/grid;
              diff_x /= rate;
              diff_y /= rate;
            }else if(o.mycplane.snap_type=='point'){
              diff_y = Math.round(diff_y / grid) * grid;
              diff_x = Math.round(diff_x / grid) * grid;
            }else if(o.mycplane.snap_type=='vline'){
              diff_x = Math.round(diff_x / grid) * grid;
            }else if(o.mycplane.snap_type=='hline'){
              diff_y = Math.round(diff_y / grid) * grid;
            }
          }else{
            ///NOTE: clear the snap-type so that it can be re-assigned 
            o.mycplane.snap_type = '';
          }
          if(o.mycplane.ismultiply==1){
            o.mycplane.rotate_ang = Math.atan2(diff_y, diff_x)/Math.PI*180;
            o.mycplane.scale_factor = Math.fround(Math.sqrt(diff_y*diff_y + diff_x*diff_x)/grid);
          }else if(o.mycplane.ismultiply==0){
            o.mycplane.move_x = diff_x ;
            o.mycplane.move_y = diff_y ;
          }
        }else{
          let diff_x = ctx.cake.posx2 - ctx.cake.posx1;
          let diff_y = ctx.cake.posy2 - ctx.cake.posy1;
          o.mycplane.origin_x += diff_x;
          o.mycplane.origin_y += diff_y;
        }
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='xyplane'){ //board_drag
        let diff_x = ctx.cake.posx2 - ctx.cake.posx1;
        let diff_y = ctx.cake.posy2 - ctx.cake.posy1;
        o.myxyplane.origin_x += diff_x;
        o.myxyplane.origin_y += diff_y;
        board_redraw(ctx,canvas);
      }
      if(ctx.cake.myop=='ball'){ // ball drag     
        let ball = o.myball.hitball;
        if(o.myball.istodo=='move'){
          let dx = ctx.cake.posx2 - ctx.cake.posx0;   
          let dy = ctx.cake.posy2 - ctx.cake.posy0;   
          if(ctx.cake.shiftKey){
            if(Math.abs(dx) <= 2 && Math.abs(dy) <= 2){
              dx = 0;   
              dy = 0;
            }else if(Math.abs(dx) > Math.abs(dy)){
              dy = 0;
            }else{
              dx = 0;
            }
          }
          if(ball){
            ball.x = ball.x0 + dx;
            ball.y = ball.y0 + dy;
          }
        }
        else if(o.myball.istodo=='size'){
          let dx = ctx.cake.posx2 - ctx.cake.posx1;
          let dy = ctx.cake.posy2 - ctx.cake.posy1;
          if(ball){
            ball.w += dx;
            ball.h += dy;
          }
        }
        else if(o.myball.istodo=='skewX'){
          let dx = ctx.cake.posx2 - ctx.cake.posx1;
          if(ball){
            ball.skewX += dx;
          }
        }
        else if(o.myball.istodo=='skewY'){
          let dy = ctx.cake.posy2 - ctx.cake.posy1;
          if(ball){
            ball.skewY += dy;
          }
        }else if(o.myball.istodo=='select'){
          o.myball.w = ctx.cake.posx2 - ctx.cake.posx0;
          o.myball.h = ctx.cake.posy2 - ctx.cake.posy0;
          let {x,y,w,h} = o.myball;
          o.myball.selection = ball_select_balls(x,y,w,h,o.myball.balls);
        }else if(o.myball.istodo=='create'){
          let x = ctx.cake.posx0;
          let y = ctx.cake.posy0;
          let dx = ctx.cake.posx2 - ctx.cake.posx0;
          let dy = ctx.cake.posy2 - ctx.cake.posy0;
          if(o.myball.hitball){
            let ball = o.myball.hitball;
            ball.w = dx;
            ball.h = dy;
          }else if(o.myball.iscreateflag){
            if(Math.abs(dx)>10 || Math.abs(dy)>10){
              o.myball.iscreateflag = 0;
              let ball = ball_new_ball(o.myball.shapeid,o.mycolorid,o.mystrokeid,x,y);
              ball.w = dx;
              ball.h = dy;
              o.myball.balls.push(ball);
              o.myball.hitball = ball;
            }
          }
        }
        board_redraw(ctx,canvas);
      }
    }
    function board_end(ctx,canvas){
      let o = ctx.cake;                
      if(o.myop=='select'){ //board_end select
        if(o.mybasis.altKey && o.mybasis.shiftKey){
        }else if(o.mybasis.altKey){
        }
        o.mybasis.altKey = 0;
        o.mybasis.shiftKey = 0;
        board_redraw(ctx,canvas);
      }
      if(o.myop=='poly'   // poly end
        || o.myop=='rect'   // poly end
        || o.myop=='elli'){ // poly end
        let {x,y,x2,y2} = o.mypoly;
        polypts_add_xy(x,y, o.mypoly.polypts);
        polypts_add_xy(x2,y2, o.mypoly.polypts);
      }
      if(o.myop=='cplane'){ //board_end
      }
      if(o.myop=='xyplane'){ //board_end
      }
      if(o.myop=='ball'){ // ball end     
        ///turn off the hit ball if it is just created
        if(o.myball.istodo=='create'){
          //o.myball.hitball = null;
        }
        o.myball.altKey = 0;
        o.myball.shiftKey = 0;
        o.myball.istodo = '';
        if(o.myball.hitball){
          o.myball.clipball = {...o.myball.hitball};
        }
        //board_redraw(ctx,canvas);
      }
    }
    function board_add_undo(ctx,canvas){
      let o = ctx.cake;
      let s0 = ctx.getImageData(0,0, canvas.width,canvas.height);
      o.myundo.s0.push(s0);
      if(o.myundo.s0.length > 10){
        o.myundo.s0.shift();
      }
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function drawHead(ctx,x0,y0,x1,y1,x2,y2,style) {
      'use strict';
      if(typeof(x0)=='string') x0=parseInt(x0);
      if(typeof(y0)=='string') y0=parseInt(y0);
      if(typeof(x1)=='string') x1=parseInt(x1);
      if(typeof(y1)=='string') y1=parseInt(y1);
      if(typeof(x2)=='string') x2=parseInt(x2);
      if(typeof(y2)=='string') y2=parseInt(y2);
      var radius=3;
      var twoPI=2*Math.PI;

      // all cases do this.
      ctx.save();
      ctx.lineWidth='1';
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.lineTo(x1,y1);
      ctx.lineTo(x2,y2);
      switch(style){
        case 0:
          // curved filled, add the bottom as an arcTo curve and fill
          var backdist=Math.sqrt(((x2-x0)*(x2-x0))+((y2-y0)*(y2-y0)));
          ctx.arcTo(x1,y1,x0,y0,.55*backdist);
          ctx.closePath();
          ctx.fill();
          break;
        case 1:
          // straight filled, add the bottom as a line and fill.
          ctx.beginPath();
          ctx.moveTo(x0,y0);
          ctx.lineTo(x1,y1);
          ctx.lineTo(x2,y2);
          ctx.lineTo(x0,y0);
          ctx.closePath();
          ctx.fill();
          break;
        case 2:
          // unfilled head, just stroke.
          ctx.closePath();
          ctx.stroke();
          break;
        case 3:
          //filled head, add the bottom as a quadraticCurveTo curve and fill
          var cpx=(x0+x1+x2)/3;
          var cpy=(y0+y1+y2)/3;
          ctx.quadraticCurveTo(cpx,cpy,x0,y0);
          ctx.closePath();
          ctx.fill();
          break;
        case 4:
          //filled head, add the bottom as a bezierCurveTo curve and fill
          var cp1x, cp1y, cp2x, cp2y,backdist;
          var shiftamt=5;
          if(x2==x0){
            // Avoid a divide by zero if x2==x0
            backdist=y2-y0;
            cp1x=(x1+x0)/2;
            cp2x=(x1+x0)/2;
            cp1y=y1+backdist/shiftamt;
            cp2y=y1-backdist/shiftamt;
          }else{
            backdist=Math.sqrt(((x2-x0)*(x2-x0))+((y2-y0)*(y2-y0)));
            var xback=(x0+x2)/2;
            var yback=(y0+y2)/2;
            var xmid=(xback+x1)/2;
            var ymid=(yback+y1)/2;

            var m=(y2-y0)/(x2-x0);
            var dx=(backdist/(2*Math.sqrt(m*m+1)))/shiftamt;
            var dy=m*dx;
            cp1x=xmid-dx;
            cp1y=ymid-dy;
            cp2x=xmid+dx;
            cp2y=ymid+dy;
          }

          ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x0,y0);
          ctx.closePath();
          ctx.fill();
          break;
      }
      ctx.restore();
    }
    function drawArrow(ctx,x1,y1,x2,y2,style,which,angle,d) {
      'use strict';
      // Ceason pointed to a problem when x1 or y1 were a string, and concatenation
      // would happen instead of addition
      if(typeof(x1)=='string') x1=parseInt(x1);
      if(typeof(y1)=='string') y1=parseInt(y1);
      if(typeof(x2)=='string') x2=parseInt(x2);
      if(typeof(y2)=='string') y2=parseInt(y2);
      style=typeof(style)!='undefined'? style:3;
      which=typeof(which)!='undefined'? which:1; // end point gets arrow
      angle=typeof(angle)!='undefined'? angle:Math.PI/8;
      d    =typeof(d)    !='undefined'? d    :8;
      // default to using drawHead to draw the head, but if the style
      // argument is a function, use it instead
      //var toDrawHead=typeof(style)!='function'?drawHead:style;
      var toDrawHead=drawHead;

      // For ends with arrow we actually want to stop before we get to the arrow
      // so that wide lines won't put a flat end on the arrow.
      //
      var dist=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
      var ratio=(dist-d/3)/dist;
      var tox, toy,fromx,fromy;
      if(which&1){
        tox=Math.round(x1+(x2-x1)*ratio);
        toy=Math.round(y1+(y2-y1)*ratio);
      }else{
        tox=x2;
        toy=y2;
      }
      if(which&2){
        fromx=x1+(x2-x1)*(1-ratio);
        fromy=y1+(y2-y1)*(1-ratio);
      }else{
        fromx=x1;
        fromy=y1;
      }

      // Draw the shaft of the arrow
      ctx.beginPath();
      ctx.moveTo(fromx,fromy);
      ctx.lineTo(tox,toy);
      ctx.stroke();

      // calculate the angle of the line
      var lineangle=Math.atan2(y2-y1,x2-x1);
      // h is the line length of a side of the arrow head
      var h=Math.abs(d/Math.cos(angle));

      if(which&1){  // handle far end arrow head
        var angle1=lineangle+Math.PI+angle;
        var topx=x2+Math.cos(angle1)*h;
        var topy=y2+Math.sin(angle1)*h;
        var angle2=lineangle+Math.PI-angle;
        var botx=x2+Math.cos(angle2)*h;
        var boty=y2+Math.sin(angle2)*h;
        drawHead(ctx,topx,topy,x2,y2,botx,boty,style);
      }
      if(which&2){ // handle near end arrow head
        var angle1=lineangle+angle;
        var topx=x1+Math.cos(angle1)*h;
        var topy=y1+Math.sin(angle1)*h;
        var angle2=lineangle-angle;
        var botx=x1+Math.cos(angle2)*h;
        var boty=y1+Math.sin(angle2)*h;
        drawHead(ctx,topx,topy,x1,y1,botx,boty,style);
      }
    }
    function getCursorPosition(evt) {
      var canvas = evt.target();
      var x;
      var y;
      if (evt.pageX != undefined && evt.pageY != undefined) {
        x = evt.pageX;
        y = evt.pageY;
      }
      else {
        x = evt.clientX + document.body.scrollLeft +
          document.documentElement.scrollLeft;
        y = evt.clientY + document.body.scrollTop +
          document.documentElement.scrollTop;
      }
      x -= canvas.offsetLeft;
      y -= canvas.offsetTop;
      return {x,y};
    }
    function getDist(x,x1,y,y1){ 
      return Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1));
    }
    /////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////
    re_scalar_func     = new RegExp("^([A-Za-z][A-Za-z0-9]*)\\\\(");
    re_scalar_var      = new RegExp("^([A-Za-z][A-Za-z0-9]*)\\\\s*(.*)$");
    re_scalar_is_oct   = new RegExp("^0o([0-7]+)\\\\s*(.*)$");    
    re_scalar_is_bin   = new RegExp("^0b([0-1]+)\\\\s*(.*)$");    
    re_scalar_is_hex   = new RegExp("^0x([0-9A-Fa-f]+)\\\\s*(.*)$");    
    re_scalar_float    = new RegExp("^(\\\\d*\\\\.\\\\d+|\\\\d*\\\\.|\\\\d+)(e\\\\d+|e\\\\+\\\\d+|e\\\\-\\\\d+|E\\\\d+|E\\\\+\\\\d+|E\\\\-\\\\d+|)\\\\s*(.*)$");    
    re_scalar_op       = new RegExp("^(>=|<=|==|!=|>|<|\\\\+|-|\\\\*|\\\\/)\\\\s*(.*)$");    
    re_scalar_real     = new RegExp("^([+-]?[\\\\d\\\\.]+)$");
    re_scalar_imag     = new RegExp("^([+-]?[\\\\d\\\\.]+)[ij]$");
    re_scalar_comp     = new RegExp("^([+-]?[\\\\d\\\\.]+)([+-]?[\\\\d\\\\.]+)[ij]$");
    re_scalar_comp2    = new RegExp("^([+-]?[\\\\d\\\\.]+)([+-]?)[ij]$");
    re_scalar_comp1    = new RegExp("^([+-]?)[ij]$");
    function extract_next_expr(s,g,z=0){
      /// extract the expression of a+1,b+1
      /// until we have just gone past the comma, in which
      /// case the comma will be discarded and the value of the expression 'a+1'
      /// is caluclated based on the variable stored with the 'g' 
      //NOTE: 's' is the input string. 'g' contains a list of arguments. 'z' is the level of nesting
      //RETURN: this function returns a float
      /// - this function will stop at the first sign of a comma,
      /// - this function will stop at the first sign of a unmatched close-parenthesis 
      /// such as x+1+y,...
      /// such as x+1)...
      var s0 = s;
      s = s.trimLeft();
      var op = '';
      var arg1 = 0;
      /// check to see if it is a comma, a left parenthis, or right 
      /// parenthesis
      var c = s.charAt(0);
      if (c === ',' || c === ')') {
        s = s.slice(1);
        return [c, s, c];
      }
      while(s.length){
        /// if the s starts with a comma or right-paren,
        /// then keep it in the s and return the current
        /// processed value
        var c = s.charAt(0);
        if(c === ',' || c === ')') {
          break;
        }
        if(c === '+' || c === '-') {
          op = c;
          s = s.substr(1);
          s = s.trimLeft();
          continue;
        }
        /// A term is always a float that is the result
        /// of '2', 'pi', '2*pi', '2/pi', '2*2*pi'. etc. 
        var my = this.extract_next_term(s,g,z+1);
        var [a,s,phrase] = my;
        ///'a' is string such as '*', '+', ')', or ','
        if(typeof a === 'number'){
          let arg2 = a;
          arg1 = this.exec_operator(op,arg1,arg2);
          op = '';//it must to be cleared because otherwise it might be used again
        }else{
          /// otherwise assume a is an operator
          op = a; 
        } 
        s = s.trimLeft();
      }
      var phrase = s0.substr(0,s0.length-s.length);
      //console.log('extract_next_expr', arg1, s, phrase);
      return [arg1,s,phrase];
    }
    function extract_next_term(s,g,z=0){
      /// a term is defined as number multiplied together with operator * or /,
      /// for instance, for '1 + 2*2 + 1', the '2*2' is to be processed by this function
      var s0 = s;
      s = s.trimLeft();
      var op = '';
      var arg1 = 0;    
      while(s.length){
        ///lookahead:
        /// if the s starts with a comma or right-paren,
        /// then keep it in the s and return the current
        /// processed value
        var c = s.charAt(0);
        if(c === ',' || c === ')' || c === '+' || c === '-') {
          break;
        }
        /// a scalar is defined as a function, a comma, a left 
        /// parenthesis, a right parenthesis, a plus, minus, 
        /// multiplication, or division sign 
        var my = this.extract_next_scalar(s,g,z+1);
        var [s1,s,phrase] = my;
        ///'a' is string such as '*', '+', ')', or ',', 
        ///'a' could also be a float           
        if(typeof s1 === 'number'){
          /// assume 'a' is 'arg2' and run the operator
          let arg2 = s1;
          arg1 = this.exec_operator(op,arg1,arg2);
          op = '';/// it is important to clear op here 
        }else{
          /// otherwise assume 'a' is an operator
          op = s1; 
        } 
        s = s.trimLeft();
      }
      var phrase = s0.substr(0,s0.length-s.length);
      //console.log('extract_next_expr', arg1, s, phrase);
      return [arg1,s,phrase];
    }
    function extract_next_scalar(s,g,z=0) {
      ///NOTE: this function returns an array of three elements: [a,s,phrase]
      /// The first one is a number if what extracted is a number. 
      ///
      /// 1. a number such as 1.234
      /// 2. an operator such as '+', '-', '*', '/', '>', '<', '>=', '<=' 
      /// 
      /// A scalar is defined as the value of a 
      /// complete function (including any
      /// nested functions as well), an parenthesized expression,
      /// a multiplication sign, or a division sign 
      var s0 = s;
      var v;
      s = s.trimLeft();
      if (s.length===0) {
        return ['','',''];
      }
      if (s.charAt(0)==='('){
        let myval = 0;
        s = s.slice(1);
        while(s.length){
          var [s1,s] = this.extract_next_expr(s,g,z+1);
          if(s1 === ')'){
            break;
          }else if(s1 === ','){
            continue;
          }else if(typeof s1 === 'number'){
            myval = s1;
            continue;
          }
          continue;
        }
        let phrase = s0.substr(0,s0.length - s.length);
        return [myval,s,phrase];
      }
      /// scalar function such as 'sin(x)'
      if ((v=re_scalar_func.exec(s))!==null) {
        let func_name = v[1];
        s = s.slice(v[0].length);
        let func_args = [];
        while(s.length){
          /// the 's' would have looked like: 'x+1, y+1, z)', we will 
          /// call extract_next_expr which will extract one of them until the comma or a right parentheiss
          /// and return its numerical value. If the returned 'a' is not a numerical value we will assume
          /// that we have exhausted all arguments of this func
          var [s1,s] = this.extract_next_expr(s,g,z+1);//extract until we see a comma or a right parenthesis
          if (typeof s1 === 'number') {
            let a = s1;
            func_args.push(a);
            continue;
          }
          if(s1 === ','){
            continue;
          }
          if(s1 === ')'){
            break;
          }
          continue;
        }
        ///NOTE: the 'args' will already have held a list of floats
        let num = this.exec_float_func(func_name,func_args,g,z+1);//returns a float
        let phrase = s0.substr(0,s0.length - s.length);
        //console.log('debug','extract_next_scalar', 'scalar_func', 'num',num, 's',s, 'g',g, 'phrase',phrase);
        return [num,s,phrase];
      } 
      /// here we need to check to see if it is a variable, such 
      /// as 'x', 'y', 'x1', 'xx1', etc. 
      if((v=re_scalar_var.exec(s))!==null){
        let key = v[1];
        s = v[2];
        let num = NaN;
        if(g && g.hasOwnProperty(key)){
          ///It could be a float or a string
          let m = g[key];
          if(typeof m === 'number'){
            num = m;
          }else if(typeof m === 'string'){
            try{
              num = parseFloat(m);
            }catch(e){
              num = NaN;
            }
          }
        }else if(key=='PI'){
          num = Math.PI;
        }else if(key=='E'){
          num = Math.E;
        }
        let phrase = s0.substr(0,s0.length - s.length);
        //console.log('extract_next_scalar', 'var_symbol', num, s, g, phrase);
        return [num,s,phrase];
      }
      if((v=re_scalar_is_oct.exec(s))!==null){
        /// '0o07'
        let num = v[1];
        s = v[2];
        num = parseInt(num,8);
        let a = num;
        let phrase = s0.substr(0,s0.length - s.length);
        return [a,s,phrase];
      }
      if((v=re_scalar_is_bin.exec(s))!==null){
        /// '0b110'
        let num = v[1];
        s = v[2];
        num = parseInt(num,2);
        let a = (num);
        let phrase = s0.substr(0,s0.length - s.length);
        return [a,s,phrase];
      }
      if((v=re_scalar_is_hex.exec(s))!==null){
        /// '0x10'
        let num = v[1];
        s = v[2];
        num = parseInt(num,16);
        let a = (num);
        let phrase = s0.substr(0,s0.length - s.length);
        return [a,s,phrase];
      }
      if((v=re_scalar_float.exec(s))!==null){
        /// if this is a float, such as 10, 11.2, 10E2, 10E-2, etc.
        let num = v[1];
        let suffix = v[2];
        s = v[3];
        if(suffix){
          num = ""+num+suffix;
        }
        num = parseFloat(num);
        let a = (num);
        let phrase = s0.substr(0,s0.length - s.length);
        return [a,s,phrase];
      }
      if((v=re_scalar_op.exec(s))!==null){
        /// such as '<', '>', '<=', '>='
        let phrase = v[0];
        let a = v[1];
        s = v[2];
        return [a,s,phrase];
      }
      if(1){
        /// something is wrong, only extract one character, and see if we can recover
        let cc = s.codePointAt(0);
        if(cc > 0xFFFF){
          let op = s.slice(0,2);
          let phrase = op;
          s = s.slice(2);
          return [op,s,phrase];
        }else{
          let op = s.slice(0,1);
          let phrase = op;
          s = s.slice(1);
          return [op,s,phrase];
        }
      }
    }
    function exec_float_func(func_name,func_args,g,z=0) {
      ///NOTE that 'func_args' would already have held a list of 'float' numbers
      switch(func_name) {
        case 'ln':
          if(func_args.length==1){
            return Math.log(func_args[0]);//natural logarithm
          }else{
            return NaN;
          }
        case 'log':
          if(func_args.length==1){
            return Math.log(func_args[0])/(Math.LN10);
          }else{
            return NaN;
          }
        case 'log2':
          if(func_args.length==1){
            return Math.log(func_args[0])/(Math.LN2);
          }else{
            return NaN;
          }
        case 'exp':
          if(func_args.length==1){
            return Math.exp(func_args[0]);
          }else{
            return NaN;
          }
        case 'pow':
          if(func_args.length==2){
            return Math.pow(func_args[0],func_args[1]);
          }else{
            return NaN;
          }
        case 'sqrt':
          if(func_args.length==1){
            return Math.sqrt(func_args[0]);     
          }else{
            return NaN;
          }
        case 'sin':
          if(func_args.length==1){
            return Math.sin(func_args[0]);
          }else{
            return NaN;
          }
        case 'cos':
          if(func_args.length==1){
            return Math.cos(func_args[0]);
          }else{
            return NaN;
          }
        case 'tan':
          if(func_args.length==1){
            return Math.tan(func_args[0]);
          }else{
            return NaN;
          }
        case 'asin':
          if(func_args.length==1){
            return Math.asin(func_args[0]);
          }else{
            return NaN;
          }
        case 'acos':
          if(func_args.length==1){
            return Math.acos(func_args[0]);
          }else{
            return NaN;
          }
        case 'atan':
          if(func_args.length==1){
            return Math.atan(func_args[0]);
          }else{
            return NaN;
          }
        case 'atan2':
          if(func_args.length==2){
            return Math.atan2(func_args[0],func_args[1]);
          }else{
            return NaN;
          }
        case 'sinh':
          if(func_args.length==1){
            return Math.sinh(func_args[0]);
          }else{
            return NaN;
          }
        case 'cosh':
          if(func_args.length==1){
            return Math.cosh(func_args[0]);
          }else{
            return NaN;
          }
        case 'tanh':
          if(func_args.length==1){
            return Math.tanh(func_args[0]);  
          }else{
            return NaN;
          }
        case 'deg2rad':
          if(func_args.length==1){
            return func_args[0]/180*Math.PI;
          }else{
            return NaN;
          }
        case 'rad2deg':
          if(func_args.length==1){
            return func_args[0]/Math.PI*180;
          }else{
            return NaN;
          }
        case 'floor':
          if(func_args.length==1){
            return Math.floor(func_args[0]);
          }else{
            return NaN;
          }
        case 'ceil':
          if(func_args.length==1){
            return Math.ceil(func_args[0]);
          }else{
            return NaN;
          }
        case 'round':
          if(func_args.length==1){
            return Math.round(func_args[0]);
          }else{
            return NaN;
          }
        case 'abs':
          if(func_args.length==1){
            return Math.abs(func_args[0]);
          }else{
            return NaN;
          }
        case 'sign':
          if(func_args.length==1){
            return Math.sign(func_args[0]);
          }else{
            return NaN;
          }
        case 'if':
          if(func_args.length==3){
            return (func_args[0] == 0) ? func_args[2] : func_args[1];
          }else{
            return NaN;
          }
        case 'isfinite':
          if(func_args.length==1){
            return Number.isFinite(func_args[0])?1:0;
          }else{
            return NaN;
          }
        case 'isnan':
          if(func_args.length==1){
            return Number.isFinite(func_args[0])?1:0;
          }else{
            return NaN;
          }
        default:
          break;
      }
      return NaN;;
    }
    function exec_operator(op,arg1,arg2,z=0) {
      switch(op) {
        case '*':
          return arg1*arg2;
          break;
        case '+':
          return arg1+arg2;
          break;
        case '-':
          return arg1-arg2;
          break;
        case '/':
          return arg1/arg2;
          break;
        case '>':
          return (arg1 > arg2) ? 1 : 0;
          break;
        case '<':
          return (arg1 < arg2) ? 1 : 0;
          break;
        case '<=':
          return (arg1 <= arg2) ? 1 : 0;
          break;
        case '>=':
          return (arg1 >= arg2) ? 1 : 0;
          break;
        case '!=':
          return (arg1 != arg2) ? 1 : 0;
          break;
        case '==':
          return (arg1 == arg2) ? 1 : 0;
          break;
        default:
          /// if the operator is not recognized simply returns the latest operand
          return arg2;
          break;
      }
    }
    function make_rect(x,y,w,h){
      return {x,y,w,h}
    }
    function expand_rect(o,d){
      var {x,y,w,h} = o;
      x -= d;
      y -= d;
      w += d+d;
      h += d+d;
      return {x,y,w,h};
    }
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    function ball_getcornerxy(ball){
      let corner_i = ball.corner_i;
      let x = 0;
      let y = 0;
      if(corner_i>=0&&corner_i<ball.points.length){
        x = ball.points[corner_i].x;
        y = ball.points[corner_i].y;
      }
      return [x,y];
    }
    function ball_getpivotxy(ball){
      let x = ball.pivot_x;
      let y = ball.pivot_y;
      return [x,y];
    }
    function ball_find_hitcorner(sx,sy, ball,ctx){
      // re-discover corners only -- no rediscovering of new hit balls
      var success = 0;
      var corner_i = -1;
      ctx.save();
      ctx.resetTransform();
      ///corners
      let corners = ball_get_corners(ball);
      let center_p = ball_get_center_p(ball);
      ///transform
      ctx.translate(ball.x,ball.y);
      ctx.rotate(ball.rotation/180*Math.PI);
      corners.forEach((pt,i) => {
        let {x,y} = pt;
        if(Number.isFinite(x) && Number.isFinite(y)){
          let path2d = new Path2D();
          const corner_size = 4;
          path2d.arc(x,y,corner_size,0,2*Math.PI,0);
          path2d.closePath();
          ctx.lineWidth=10;
          if(ctx.isPointInPath(path2d, sx,sy)){
            corner_i = i;
            success = 1;
          }else if(ctx.isPointInStroke(path2d, sx,sy)){
            corner_i = i;
            success = 1;
          }
        }
      });
      ctx.restore();
      return corner_i;
    }
    function ball_find_hitball(sx,sy, balls,ctx){
      var ball1 = ball_find_hitball_in_stroke(sx,sy, balls,ctx);
      var ball2 = ball_find_hitball_in_path(sx,sy, balls,ctx);
      if(ball1){
        return ball1;
      }
      if(ball2){
        return ball2;
      }
      return null;
    }
    function ball_find_hitball_in_stroke(sx,sy, balls,ctx){
      //need to find out if we need to switch to a different hit ball
      var hitball = null;
      balls.forEach((ball,j) => {
        ctx.save();
        ///path2d
        let path2d = ball_get_path2d(ball);
        ///transform
        ctx.translate(ball.x,ball.y);
        ctx.rotate(ball.rotation/180*Math.PI);
        ///test
        ctx.lineWidth=10;
        if(ctx.isPointInStroke(path2d, sx,sy)){
          hitball = ball;
        }
        ctx.restore();
      });
      return hitball;
    }
    function ball_find_hitball_in_path(sx,sy, balls,ctx){
      //need to find out if we need to switch to a different hit ball
      var hitball = null;
      balls.forEach((ball,j) => {
        ctx.save();
        ///path2d
        let path2d = ball_get_path2d(ball);
        ///transform
        ctx.translate(ball.x,ball.y);
        ctx.rotate(ball.rotation/180*Math.PI);
        ///test
        ctx.lineWidth=10;
        if(ctx.isPointInPath(path2d, sx,sy)){
          hitball = ball;
        }
        ctx.restore();
      });
      return hitball;
    }
    function ball_get_path2d(ball){
      let path2d = new Path2D();
      let shape = all_shapes[ball.shapeid];
      switch(shape){
        case 'rect': {
          ///rect
          path2d.moveTo(0, 0);
          path2d.lineTo(ball.w,                 ball.skewY);
          path2d.lineTo(ball.w+ball.skewX,      ball.h+ball.skewY);
          path2d.lineTo(ball.skewX,             ball.h);
          path2d.closePath();
          break;
        }
        case 'triangle': {
          ///triangle lower-left
          path2d.moveTo(0, 0);
          path2d.lineTo(ball.w+ball.skewX,      ball.h+ball.skewY);
          path2d.lineTo(ball.skewX,             ball.h);
          path2d.closePath();
          break;
        }
        case 'ellipse': {
          ///ellipse
          let cx = ball.w/2;
          let cy = ball.h/2;
          let rx = Math.abs(ball.w/2);
          let ry = Math.abs(ball.h/2);
          let rotation = 0;
          let sAngle = 0;
          let eAngle = 2*Math.PI;
          //path2d.ellipse(cx,cy,rx,ry,rotation,sAngle,eAngle);
          let p0 = [0, 0];
          let p1 = [ball.w,                 ball.skewY];
          let p2 = [ball.w+ball.skewX,      ball.h+ball.skewY];
          let p3 = [ball.skewX,             ball.h];
          let [x1,y1] = MidPoint(p3,p0,0.5);
          let [x2,y2] = MidPoint(p0,p1,0.5);
          let [x3,y3] = MidPoint(p1,p2,0.5);
          let [x4,y4] = MidPoint(p2,p3,0.5);
          path2d.moveTo(x1,y1);
          if(1){
            let [cp1x,cp1y] = MidPoint(p3,p0,1.55/2);
            let [cp2x,cp2y] = MidPoint(p1,p0,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x2,y2);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p0,p1,1.55/2);
            let [cp2x,cp2y] = MidPoint(p2,p1,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x3,y3);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p1,p2,1.55/2);
            let [cp2x,cp2y] = MidPoint(p3,p2,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x4,y4);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p2,p3,1.55/2);
            let [cp2x,cp2y] = MidPoint(p0,p3,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x1,y1);
          }
          path2d.closePath();
          break;
        }
        case 'pentagon': {
          let p0 = [0, 0];
          let p1 = [ball.w,                 ball.skewY];
          let p2 = [ball.w+ball.skewX,      ball.h+ball.skewY];
          let p3 = [ball.skewX,             ball.h];
          let rt1 = 1/(1+0.809);
          let rt2 = (1-0.309)/(1+0.809);
          let rt3 = 0.19099;                  
          let [x1,y1] = MidPoint(p0,p1,0.50);
          let [x2,y2] = MidPoint(p1,p2,rt2);
          let [x3,y3] = MidPoint(p2,p3,rt3);
          let [x4,y4] = MidPoint(p3,p2,rt3);
          let [x5,y5] = MidPoint(p0,p3,rt2);
          ///triangle lower-left
          path2d.moveTo(x1, y1);
          path2d.lineTo(x2, y2);
          path2d.lineTo(x3, y3);
          path2d.lineTo(x4, y4);
          path2d.lineTo(x5, y5);
          path2d.closePath();
          break;
        }
        case 'hexagon': {
          let p0 = [0, 0];
          let p1 = [ball.w,                 ball.skewY];
          let p2 = [ball.w+ball.skewX,      ball.h+ball.skewY];
          let p3 = [ball.skewX,             ball.h];
          let [x1,y1] = MidPoint(p0,p1,0.50);
          let [x2,y2] = MidPoint(p1,p2,0.25);
          let [x3,y3] = MidPoint(p1,p2,0.75);
          let [x4,y4] = MidPoint(p2,p3,0.50);
          let [x5,y5] = MidPoint(p3,p0,0.25);
          let [x6,y6] = MidPoint(p3,p0,0.75);
          ///triangle lower-left
          path2d.moveTo(x1, y1);
          path2d.lineTo(x2, y2);
          path2d.lineTo(x3, y3);
          path2d.lineTo(x4, y4);
          path2d.lineTo(x5, y5);
          path2d.lineTo(x6, y6);
          path2d.closePath();
          break;
        }
        default: {
          ///straight line
          path2d.moveTo(0, 0);
          path2d.lineTo(ball.w+ball.skewX,      ball.h+ball.skewY);
          break;
        }
      }
      return path2d;
    }
    function ball_get_corners(ball){
      let {w,h} = ball;
      var corners = [];
      var shape = all_shapes[ball.shapeid];
      switch(shape){
        case 'rect':  
        case 'hexagon':  
        case 'pentagon':  
        case 'ellipse': {
          corners.push({x:0,                      y:0});
          corners.push({x:ball.w,                 y:ball.skewY});
          corners.push({x:ball.w+ball.skewX,      y:ball.h+ball.skewY});
          corners.push({x:ball.skewX,             y:ball.h});
          break;
        }
        case 'triangle': {
          ///lower-left triangle
          corners.push({x:0,                      y:0});
          corners.push({x:NaN,                    y:NaN       });
          corners.push({x:ball.w+ball.skewX,      y:ball.h+ball.skewY});
          corners.push({x:ball.skewX,             y:ball.h});
          break;
        }
        default: {
          ///straight line
          corners.push({x:0,                      y:0});
          corners.push({x:NaN,                    y:NaN       });
          corners.push({x:ball.w+ball.skewX,      y:ball.h+ball.skewY});
          corners.push({x:NaN,                    y:NaN       });
          break;
        }
      }
      return corners;
    }
    function ball_get_center_p(ball){
      let {w,h} = ball;
      let p1 = {x:0,                      y:0};
      let p2 = {x:ball.w+ball.skewX,      y:ball.h+ball.skewY};
      let x = (p1.x + p2.x)/2;
      let y = (p1.y + p2.y)/2;
      return {x,y};   
    }
    function ball_select_balls(rx,ry,rw,rh,balls){
      let selection = [];
      balls.forEach((ball,i)=>{
        let center_p = ball_get_center_p(ball);
        let {x,y} = center_p;
        let sx = x + ball.x;
        let sy = y + ball.y;
        if(IsPointInRect(sx,sy, rx,ry,rw,rh)){
          selection.push(ball);
        }
      });
      return selection;
    }
    function ball_new_ball(shapeid,colorid,strokeid,x,y){
      let ball = {corner_i:-1,shapeid,colorid,strokeid,x,y,w:30,h:30,skewX:0,skewY:0,rotation:0};
      return ball;
    }
    function poly_get_path2d(sh,w,h){
      let path2d = new Path2D();
      let skewX = 0;
      let skewY = 0;
      switch(sh){
        case 'rect': {
          ///rect
          path2d.moveTo(0, 0);
          path2d.lineTo(w,                 skewY);
          path2d.lineTo(w+skewX,      h+skewY);
          path2d.lineTo(skewX,             h);
          path2d.closePath();
          break;
        }
        case 'elli': {
          ///ellipse
          let cx = w/2;
          let cy = h/2;
          let rx = Math.abs(w/2);
          let ry = Math.abs(h/2);
          let rotation = 0;
          let sAngle = 0;
          let eAngle = 2*Math.PI;
          //path2d.ellipse(cx,cy,rx,ry,rotation,sAngle,eAngle);
          let p0 = [0, 0];
          let p1 = [w,                 skewY];
          let p2 = [w+skewX,      h+skewY];
          let p3 = [skewX,             h];
          let [x1,y1] = MidPoint(p3,p0,0.5);
          let [x2,y2] = MidPoint(p0,p1,0.5);
          let [x3,y3] = MidPoint(p1,p2,0.5);
          let [x4,y4] = MidPoint(p2,p3,0.5);
          path2d.moveTo(x1,y1);
          if(1){
            let [cp1x,cp1y] = MidPoint(p3,p0,1.55/2);
            let [cp2x,cp2y] = MidPoint(p1,p0,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x2,y2);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p0,p1,1.55/2);
            let [cp2x,cp2y] = MidPoint(p2,p1,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x3,y3);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p1,p2,1.55/2);
            let [cp2x,cp2y] = MidPoint(p3,p2,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x4,y4);
          }
          if(1){
            let [cp1x,cp1y] = MidPoint(p2,p3,1.55/2);
            let [cp2x,cp2y] = MidPoint(p0,p3,1.55/2);
            path2d.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x1,y1);
          }
          path2d.closePath();
          break;
        }
        default: {
          ///straight line
          path2d.moveTo(0, 0);
          path2d.lineTo(w+skewX,      h+skewY);
          break;
        }
      }
      return path2d;
    }
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////
    function IsPointInRect(px,py, rx,ry,rw,rh){
      if(px > rx && px < (rx+rw) &&
         py > ry && py < (ry+rh)){
        return 1;
      }else{
        return 0;
      }
    }
    function MidPoint(p1,p2,where){
      let x = p1[0]+(p2[0]-p1[0])*where;
      let y = p1[1]+(p2[1]-p1[1])*where;
      return [x,y];
    }
    function ResizeImageData(odata,iwidth,iheight,ctx) {
      let owidth = odata.width;
      let oheight = odata.height;
      let idata = ctx.createImageData(iwidth, iheight);
      for(let row = 0; row < iheight; row++) {
        for(let col = 0; col < iwidth; col++) {
          let i = row*iwidth + col;
          let ROW = Math.floor(row*(oheight/iheight));
          let COL = Math.floor(col*(owidth/iwidth));
          let I = ROW*owidth + COL;
          idata.data[i*4 + 0] = odata.data[I*4 + 0];
          idata.data[i*4 + 1] = odata.data[I*4 + 1];
          idata.data[i*4 + 2] = odata.data[I*4 + 2];
          idata.data[i*4 + 3] = odata.data[I*4 + 3];
        }
      }
      return idata;
    }
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    function PutImageData(src,x,y,ctx) {
      var w = src.width;
      var h = src.height;
      var dest = ctx.getImageData(x,y,w,h);
      for(var row = 0; row < h; row++) {
        for(var col = 0; col < w; col++) {
          let i = row*w + col;
          if(src.data[i*4+3]==0){
          }else{
            dest.data[i*4 + 0] = src.data[i*4 + 0];
            dest.data[i*4 + 1] = src.data[i*4 + 1];
            dest.data[i*4 + 2] = src.data[i*4 + 2];
            dest.data[i*4 + 3] = src.data[i*4 + 3];
          }
        }
      }
      ctx.putImageData(dest,x,y);
    }
    `;
  }
}
module.exports = { NitrilePreviewFlowerpot };
////////////////////////////////////////////////////////////////////////////
//
// require.main === module
//
////////////////////////////////////////////////////////////////////////////
const { NitrilePreviewBase } = require('./nitrile-preview-base');
class Server extends NitrilePreviewBase {
  constructor() {
    super();
  }
  async run(){
    const { NitrilePreviewParser } = require('./nitrile-preview-parser');
    const fs = require('fs');
    const path = require('path');
    const process = require('process');
    var fname = process.argv[2];    
    if(!fname){
      throw "File name is empty"
    }else if(path.extname(fname)==='.md'){
      var parser = new NitrilePreviewParser();
      await parser.read_file_async(fname)
      await parser.read_import_async();
      var xhtmlfile = `${fname.slice(0,fname.length-path.extname(fname).length)}.xhtml`;
      var translator = new NitrilePreviewFlowerpot(parser);
      var data = translator.to_data();
      var xhtml = `\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<meta http-equiv='default-style' content='text/html' charset='utf-8'/>
<script>
//<![CDATA[
${data.script}
//]]>
</script>
<style>
${data.stylesheet}
</style>
</head>
<body>
${data.body}
</body>
</html>
`;
      await this.write_text_file(fs,xhtmlfile,xhtml);
      console.log(`written to ${xhtmlfile}`);
    }else{
      throw "File does not end with .md"
    }
  }
}
if(require.main===module){
  var server = new Server();
  server.run();
}
